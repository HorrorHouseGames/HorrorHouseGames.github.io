<!DOCTYPE html>
<html>
<head>
    <title>Endless Maze Explorer 3D - Haunted Forest</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            height: 100%; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            background: #000; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            user-select: none; 
            -webkit-touch-callout: none; 
        }
        #gameCanvas { 
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 0; 
        }
        #minimap {
            border: 1px solid black;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            transition: all 0.5s ease;
            z-index: 2;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            transition: transform 0.3s ease;
            z-index: 2;
        }
        #hud.collapsed {
            transform: translateX(-100%);
        }
        #toggle-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 30px;
            height: 30px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            z-index: 3;
        }
        #toggle-hud:hover { background: #cc3333; }
        #statusBars {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100px;
            z-index: 2;
        }
        .statusBarContainer {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }
        #staminaBar { background: #00f; }
        #healthBar { background: #f00; }
        #flashlightBar { background: #ff8800; }
        .statusBar {
            width: 100%;
            height: 100%;
            transition: width 0.1s;
        }
        #gameOverOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            z-index: 4;
        }
        #damageFlash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 1;
        }
        #gameOverOverlay button, #swap-joysticks, #toggle-stones, #reveal-map, #sprint-button, #attack-button {
            padding: 5px 10px;
            font-size: 12px;
            margin-top: 5px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
            touch-action: manipulation;
        }
        #gameOverOverlay button:hover, #swap-joysticks:hover, #toggle-stones:hover, #reveal-map:hover, #sprint-button:hover, #attack-button:hover { background-color: #cc3333; }
        #joystick-move, #joystick-camera {
            position: absolute;
            bottom: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
            display: none;
            z-index: 2;
        }
        #joystick-move { left: 20px; }
        #joystick-camera { right: 20px; }
        #joystick-move-knob, #joystick-camera-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        #sprint-button, #attack-button {
            position: absolute;
            bottom: 130px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            z-index: 2;
        }
        #attack-button { right: 90px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <canvas id="minimap"></canvas>
    <div id="gameCanvas"></div>
    <div id="hud">
        Level: <span id="level">1</span><br>
        Score: <span id="score">0</span><br>
        Shards: <span id="shards">0/0 found</span><br>
        Light Sources: <span id="lightSources">0/0 found</span><br>
        Ghosts Eliminated: <span id="ghostsEliminated">0</span><br>
        <span id="shardMessage"></span>
        <div id="controls-info"></div>
        <button id="swap-joysticks" style="display: none;">Swap Joysticks</button>
        <button id="toggle-stones">Hide Path Stones</button>
        <button id="reveal-map">Reveal Map</button>
    </div>
    <div id="gameOverOverlay">
        <h2>Game Over</h2>
        <p id="gameOverMessage">Your flashlight ran out of power!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restart-button">Restart</button>
    </div>
    <div id="damageFlash"></div>
    <div id="joystick-move">
        <div id="joystick-move-knob"></div>
    </div>
    <div id="joystick-camera">
        <div id="joystick-camera-knob"></div>
    </div>
    <button id="sprint-button" style="display: none;">RUN</button>
    <button id="attack-button" style="display: none;">ATK</button>
    <button id="toggle-hud">â˜°</button>
    <div id="statusBars">
        <div class="statusBarContainer"><div id="healthBar" class="statusBar"></div></div>
        <div class="statusBarContainer"><div id="flashlightBar" class="statusBar"></div></div>
        <div class="statusBarContainer"><div id="staminaBar" class="statusBar"></div></div>
    </div>

    <script>
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;
        const hud = {
            level: document.getElementById('level'),
            score: document.getElementById('score'),
            shards: document.getElementById('shards'),
            lightSources: document.getElementById('lightSources'),
            ghostsEliminated: document.getElementById('ghostsEliminated'),
            shardMessage: document.getElementById('shardMessage'),
            controlsInfo: document.getElementById('controls-info'),
            swapJoysticks: document.getElementById('swap-joysticks'),
            toggleStones: document.getElementById('toggle-stones'),
            revealMap: document.getElementById('reveal-map')
        };
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreSpan = document.getElementById('finalScore');
        const restartButton = document.getElementById('restart-button');
        const damageFlash = document.getElementById('damageFlash');
        const joystickMove = document.getElementById('joystick-move');
        const joystickMoveKnob = document.getElementById('joystick-move-knob');
        const joystickCamera = document.getElementById('joystick-camera');
        const joystickCameraKnob = document.getElementById('joystick-camera-knob');
        const sprintButton = document.getElementById('sprint-button');
        const attackButton = document.getElementById('attack-button');
        const toggleHudButton = document.getElementById('toggle-hud');
        const statusBars = {
            healthBar: document.getElementById('healthBar'),
            flashlightBar: document.getElementById('flashlightBar'),
            staminaBar: document.getElementById('staminaBar')
        };

        const hudElement = document.getElementById('hud');

        const tileSize = 1;
        const playerSize = 0.3;
        const baseMazeSize = 15;
        const sizeIncrease = 6;
        const maxMazeSize = 100;
        let mazeWidth = baseMazeSize;
        let mazeHeight = baseMazeSize;
        let player = { x: tileSize, z: tileSize, speed: 0.025, lastX: tileSize, lastZ: tileSize, health: 100 };
        let goal = { x: 0, z: 0 };
        let maze = [];
        let trees = [];
        let shards = [];
        let lightSources = [];
        let ghosts = [];
        let score = 0;
        let levelsCompleted = 0;
        let ghostsEliminated = 0;
        let mainPath = [];
        let deadEnds = [];
        let optimalPath = [];
        let flashlightPower = 100;
        let stamina = 3000;
        const maxStamina = 3000;
        const staminaRecoveryRate = maxStamina / 3000;
        const sprintSpeed = 0.05;
        const maxFlashlightIntensity = 2.5;
        const minFlashlightDistance = 1;
        const maxFlashlightDistance = 10;
        const flashlightDrainRate = 1;
        let gameOver = false;
        let visitedTiles = new Set();
        let isMinimapExpanded = false;
        let stonesVisible = true;
        let stoneMeshes = [];
        let lastBeamTime = 0;
        const beamCooldown = 1000;
        const ghostAttackRange = 5 * tileSize;

        const minGroundHeight = 0.0;
        const maxGroundHeight = 0.1;
        const minCanopySize = 0.9;
        const maxCanopySize = 1.2;
        const minTrunkWidth = 0.2;
        const maxTrunkWidth = 0.4;
        const minTrunkHeight = 1.2;
        const maxTrunkHeight = 2.2;
        const minPathStoneRadius = tileSize / 20;
        const maxPathStoneRadius = tileSize / 2;
        const pathWidth = 1;
        const trunkOffsetY = -0.7;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById('gameCanvas').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambientLight);

        const flashlight = new THREE.SpotLight(0xaaaaaa, maxFlashlightIntensity, maxFlashlightDistance, Math.PI / 3, 0.9);
        flashlight.position.set(0, 0.5, 0);
        flashlight.target = new THREE.Object3D();
        flashlight.target.position.set(0, 0, -1);
        camera.add(flashlight);
        camera.add(flashlight.target);
        scene.add(camera);

        scene.fog = new THREE.Fog(0x000000, 8, 12);

        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => controls.lock());
        document.addEventListener('touchstart', (e) => {
            if (!controls.isLocked && !gameOver) {
                controls.lock();
            }
            e.preventDefault();
        }, { passive: false });

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, sprint = false, shootBeam = false;
        document.addEventListener('keydown', (e) => {
            if (!gameOver) {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': if (stamina > 0) sprint = true; break;
                    case 'Space': if (!isMinimapExpanded) toggleMinimap(); break;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft':
                case 'ShiftRight': sprint = false; break;
                case 'Space': if (isMinimapExpanded) toggleMinimap(); break;
            }
        });
        document.addEventListener('mousedown', (e) => {
            if (!gameOver && e.button === 0) shootBeam = true;
        });
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) shootBeam = false;
        });

        let moveJoystickActive = false, cameraJoystickActive = false;
        let moveJoystickDeltaX = 0, moveJoystickDeltaY = 0;
        let cameraJoystickDeltaX = 0, cameraJoystickDeltaY = 0;
        const joystickRadius = 50;

        let isHudCollapsed = false;
        let isJoystickSwapped = false;
        if (navigator.maxTouchPoints > 0) {
            console.log("Setting up mobile controls");
            joystickMove.style.display = 'block';
            joystickCamera.style.display = 'block';
            sprintButton.style.display = 'block';
            attackButton.style.display = 'block';
            toggleHudButton.style.display = 'block';
            hud.swapJoysticks.style.display = 'block';
            isHudCollapsed = true;
            hudElement.classList.add('collapsed');

            function setupJoystick(joystickElement, knobElement, isMoveDefault) {
                const isMove = isJoystickSwapped ? !isMoveDefault : isMoveDefault;
                joystickElement.addEventListener('touchstart', (e) => {
                    if (!gameOver && e.touches.length <= 2) {
                        const touch = e.touches[0];
                        const rect = joystickElement.getBoundingClientRect();
                        const centerX = rect.left + joystickRadius;
                        const centerY = rect.top + joystickRadius;
                        let dx = touch.clientX - centerX;
                        let dy = isMove ? touch.clientY - centerY : 0;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > joystickRadius) {
                            dx = dx * joystickRadius / distance;
                            dy = dy * joystickRadius / distance;
                        }
                        if (isMove) {
                            moveJoystickActive = true;
                            moveJoystickDeltaX = dx;
                            moveJoystickDeltaY = dy;
                        } else {
                            cameraJoystickActive = true;
                            cameraJoystickDeltaX = 0;
                            cameraJoystickDeltaY = 0;
                        }
                        updateJoystickPosition(knobElement, centerX + dx, centerY + dy, joystickElement);
                        e.preventDefault();
                    }
                }, { passive: false });

                joystickElement.addEventListener('touchmove', (e) => {
                    if (!gameOver && e.touches.length <= 2) {
                        const touch = e.touches[isMove && moveJoystickActive ? 0 : 1] || e.touches[0];
                        const rect = joystickElement.getBoundingClientRect();
                        const centerX = rect.left + joystickRadius;
                        const centerY = rect.top + joystickRadius;
                        let dx = touch.clientX - centerX;
                        let dy = isMove ? touch.clientY - centerY : 0;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > joystickRadius) {
                            dx = dx * joystickRadius / distance;
                            dy = dy * joystickRadius / distance;
                        }
                        if (isMove) {
                            moveJoystickDeltaX = dx;
                            moveJoystickDeltaY = dy;
                        } else {
                            cameraJoystickDeltaX = dx;
                            cameraJoystickDeltaY = 0;
                        }
                        updateJoystickPosition(knobElement, centerX + dx, centerY + dy, joystickElement);
                        e.preventDefault();
                    }
                }, { passive: false });

                joystickElement.addEventListener('touchend', (e) => {
                    if (!gameOver) {
                        if (isMove) {
                            moveJoystickActive = false;
                            moveJoystickDeltaX = 0;
                            moveJoystickDeltaY = 0;
                        } else {
                            cameraJoystickActive = false;
                            cameraJoystickDeltaX = 0;
                            cameraJoystickDeltaY = 0;
                        }
                        knobElement.style.left = '50%';
                        knobElement.style.top = '50%';
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            function updateJoystickPosition(knob, x, y, joystickElement) {
                const rect = joystickElement.getBoundingClientRect();
                knob.style.left = `${x - rect.left}px`;
                knob.style.top = `${y - rect.top}px`;
                knob.style.display = 'block';
            }

            setupJoystick(joystickMove, joystickMoveKnob, true);
            setupJoystick(joystickCamera, joystickCameraKnob, false);
            sprintButton.addEventListener('touchstart', (e) => { if (stamina > 0) sprint = true; e.preventDefault(); }, { passive: false });
            sprintButton.addEventListener('touchend', (e) => { sprint = false; e.preventDefault(); }, { passive: false });
            attackButton.addEventListener('touchstart', (e) => { shootBeam = true; e.preventDefault(); }, { passive: false });
            attackButton.addEventListener('touchend', (e) => { shootBeam = false; e.preventDefault(); }, { passive: false });
            hud.swapJoysticks.addEventListener('click', () => {
                isJoystickSwapped = !isJoystickSwapped;
                joystickMove.style.left = isJoystickSwapped ? 'auto' : '20px';
                joystickMove.style.right = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.left = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.right = isJoystickSwapped ? 'auto' : '20px';
                sprintButton.style.left = isJoystickSwapped ? '20px' : 'auto';
                sprintButton.style.right = isJoystickSwapped ? 'auto' : '20px';
                attackButton.style.left = isJoystickSwapped ? '90px' : 'auto';
                attackButton.style.right = isJoystickSwapped ? 'auto' : '90px';
            });
            toggleHudButton.addEventListener('click', () => {
                isHudCollapsed = !isHudCollapsed;
                hudElement.classList.toggle('collapsed', isHudCollapsed);
                toggleHudButton.style.left = isHudCollapsed ? '10px' : '150px';
            });
        }

        function generateMaze() {
            console.log("Starting maze generation");
            mazeWidth = Math.min(baseMazeSize + sizeIncrease * levelsCompleted, maxMazeSize);
            mazeHeight = mazeWidth;

            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1);
                }
                maze.push(row);
            }

            let startX = Math.floor(mazeWidth / 2);
            let startZ = Math.floor(mazeHeight / 2);
            let goalX = mazeWidth - 4;
            let goalZ = mazeHeight - 4;

            const stack = [{ x: startX, z: startZ }];
            maze[startZ][startX] = 0;
            const basePathTiles = Math.floor((mazeWidth * mazeHeight) / 8);
            const maxPathTiles = basePathTiles + levelsCompleted * 20;
            let pathTiles = 1;

            function carvePath(x, z) {
                if (pathTiles >= maxPathTiles) return;

                const directions = [
                    { dx: 4, dz: 0 }, { dx: -4, dz: 0 },
                    { dx: 0, dz: 4 }, { dx: 0, dz: -4 }
                ].sort(() => Math.random() - 0.5);

                for (const dir of directions) {
                    const newX = x + dir.dx;
                    const newZ = z + dir.dz;

                    if (newX >= 2 && newX < mazeWidth - 2 && newZ >= 2 && newZ < mazeHeight - 2 &&
                        maze[newZ][newX] === 1 && pathTiles < maxPathTiles) {
                        const stepX = dir.dx === 0 ? 0 : dir.dx > 0 ? 1 : -1;
                        const stepZ = dir.dz === 0 ? 0 : dir.dz > 0 ? 1 : -1;
                        let currentX = x;
                        let currentZ = z;
                        while (currentX !== newX || currentZ !== newZ) {
                            currentX += stepX;
                            currentZ += stepZ;
                            if (maze[currentZ][currentX] === 1) {
                                maze[currentZ][currentX] = 0;
                                pathTiles++;
                            }
                        }
                        stack.push({ x: newX, z: newZ });
                        carvePath(newX, newZ);
                    }
                }
            }

            carvePath(startX, startZ);

            function ensureGoalReachable() {
                let closestPathX = startX;
                let closestPathZ = startZ;
                let minDist = Infinity;

                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (maze[z][x] === 0) {
                            const dist = Math.abs(x - goalX) + Math.abs(z - goalZ);
                            if (dist < minDist) {
                                minDist = dist;
                                closestPathX = x;
                                closestPathZ = z;
                            }
                        }
                    }
                }

                let currentX = goalX;
                let currentZ = goalZ;
                while (currentX !== closestPathX || currentZ !== closestPathZ) {
                    if (currentX < closestPathX) currentX++;
                    else if (currentX > closestPathX) currentX--;
                    else if (currentZ < closestPathZ) currentZ++;
                    else if (currentZ > closestPathZ) currentZ--;
                    if (maze[currentZ][currentX] === 1) maze[currentZ][currentX] = 0;
                }

                goalX = currentX;
                goalZ = currentZ;
            }

            ensureGoalReachable();

            const tempMaze = maze.map(row => [...row]);
            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1);
                }
                maze.push(row);
            }

            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (tempMaze[z][x] === 0) {
                        maze[z][x] = 0;
                        if (x > 0 && tempMaze[z][x-1] !== 0) maze[z][x-1] = 2;
                        if (x < mazeWidth - 1 && tempMaze[z][x+1] !== 0) maze[z][x+1] = 2;
                        if (z > 0 && tempMaze[z-1][x] !== 0) maze[z-1][x] = 2;
                        if (z < mazeHeight - 1 && tempMaze[z+1][x] !== 0) maze[z+1][x] = 2;
                    }
                }
            }

            function findOptimalPath() {
                const queue = [{ x: startX, z: startZ, path: [{ x: startX, z: startZ }] }];
                const visited = new Set([`${startX},${startZ}`]);
                const directions = [
                    { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
                    { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
                ];

                while (queue.length > 0) {
                    const { x, z, path } = queue.shift();
                    if (x === goalX && z === goalZ) return path;

                    for (const dir of directions) {
                        const newX = x + dir.dx;
                        const newZ = z + dir.dz;
                        const key = `${newX},${newZ}`;
                        if (newX >= 0 && newX < mazeWidth && newZ >= 0 && newZ < mazeHeight &&
                            maze[newZ][newX] === 0 && !visited.has(key)) {
                            visited.add(key);
                            queue.push({ x: newX, z: newZ, path: [...path, { x: newX, z: newZ }] });
                        }
                    }
                }
                console.error("No optimal path found!");
                return [];
            }

            mainPath = [];
            deadEnds = [];
            const pathSet = new Set();
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        mainPath.push({ x, z });
                        pathSet.add(`${x},${z}`);
                    }
                }
            }

            const targetDeadEnds = 3 + Math.floor(levelsCompleted / 2);
            for (let i = 0; i < targetDeadEnds; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const startIdx = Math.floor(Math.random() * mainPath.length);
                    const { x, z } = mainPath[startIdx];
                    const directions = [
                        { dx: 4, dz: 0 }, { dx: -4, dz: 0 },
                        { dx: 0, dz: 4 }, { dx: 0, dz: -4 }
                    ];
                    const dir = directions[Math.floor(Math.random() * 4)];
                    const endX = x + dir.dx;
                    const endZ = z + dir.dz;
                    if (endX >= 2 && endX < mazeWidth - 2 && endZ >= 2 && endZ < mazeHeight - 2 &&
                        maze[endZ][endX] === 1 && !pathSet.has(`${endX},${endZ}`)) {
                        const stepX = dir.dx === 0 ? 0 : dir.dx > 0 ? 1 : -1;
                        const stepZ = dir.dz === 0 ? 0 : dir.dz > 0 ? 1 : -1;
                        let currentX = x;
                        let currentZ = z;
                        while (currentX !== endX || currentZ !== endZ) {
                            currentX += stepX;
                            currentZ += stepZ;
                            maze[currentZ][currentX] = 0;
                            if (currentX > 0) maze[currentZ][currentX-1] = 2;
                            if (currentX < mazeWidth - 1) maze[currentZ][currentX+1] = 2;
                            if (currentZ > 0) maze[currentZ-1][currentX] = 2;
                            if (currentZ < mazeHeight - 1) maze[currentZ+1][currentX] = 2;
                        }
                        deadEnds.push({ x: endX, z: endZ });
                        mainPath.push({ x: endX, z: endZ });
                        pathSet.add(`${endX},${endZ}`);
                        break;
                    }
                    attempts++;
                }
            }

            optimalPath = findOptimalPath();
            if (optimalPath.length === 0) {
                console.error("Failed to generate solvable maze, retrying...");
                return generateMaze();
            }

            player.x = startX * tileSize;
            player.z = startZ * tileSize;
            player.lastX = player.x;
            player.lastZ = player.z;
            player.health = 100;
            goal.x = goalX * tileSize;
            goal.z = goalZ * tileSize;

            shards = [];
            for (let z = 1; z < mazeHeight - 1; z++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    if (maze[z][x] === 0) {
                        let groundCount = 0;
                        if (maze[z][x-1] === 2) groundCount++;
                        if (maze[z][x+1] === 2) groundCount++;
                        if (maze[z-1][x] === 2) groundCount++;
                        if (maze[z+1][x] === 2) groundCount++;
                        if (groundCount === 3) {
                            shards.push({ x: x * tileSize, z: z * tileSize, collected: false, phase: Math.random() * Math.PI * 2 });
                        }
                    }
                }
            }

            lightSources = [];
            for (let i = 0; i < optimalPath.length; i += 5) {
                const p = optimalPath[i];
                lightSources.push({ x: p.x * tileSize, z: p.z * tileSize, collected: false, phase: Math.random() * Math.PI * 2 });
            }

            ghosts = [];
            shards.forEach(shard => {
                const shardX = Math.floor(shard.x / tileSize);
                const shardZ = Math.floor(shard.z / tileSize);
                const spawnOptions = [];
                for (let dz = -1; dz <= 1; dz++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const newX = shardX + dx;
                        const newZ = shardZ + dz;
                        const distToStart = Math.sqrt((newX - startX) ** 2 + (newZ - startZ) ** 2);
                        if (newX >= 0 && newX < mazeWidth && newZ >= 0 && newZ < mazeHeight &&
                            (maze[newZ][newX] === 0 || maze[newZ][newX] === 2) && distToStart > 5) {
                            spawnOptions.push({ x: newX * tileSize, z: newZ * tileSize });
                        }
                    }
                }
                if (spawnOptions.length > 0 && Math.random() < 0.5) {
                    const spawn = spawnOptions[Math.floor(Math.random() * spawnOptions.length)];
                    const ghostGeometry = new THREE.SphereGeometry(tileSize / 3, 16, 16);
                    const ghostMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xaaaaaa, 
                        transparent: true, 
                        opacity: 0.7, 
                        specular: 0x111111, 
                        shininess: 5 
                    });
                    const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
                    ghost.position.set(spawn.x + tileSize / 2, tileSize / 2, spawn.z + tileSize / 2);
                    scene.add(ghost);
                    ghosts.push({ 
                        mesh: ghost, 
                        spawnX: spawn.x,
                        spawnZ: spawn.z,
                        x: spawn.x, 
                        z: spawn.z, 
                        health: 50, 
                        speed: 0.03, 
                        lastAttack: 0, 
                        attackCooldown: 2000,
                        hitTime: 0
                    });
                }
            });

            trees = [];
            visitedTiles = new Set();
            visitedTiles.add(`${startX},${startZ}`);
            stoneMeshes = [];

            while (scene.children.length > 2) {
                scene.remove(scene.children[2]);
            }

            const groundShape = new THREE.Shape();
            groundShape.moveTo(-tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, -tileSize / 2);
            const groundColors = [0x4f2f1f, 0x2f4f2f, 0x4f4f1f];
            const canopyColors = [0x1f3f1f, 0x3f2f1f, 0x3f3f1f];
            const trunkColors = [0x2a1f15, 0x1f150f, 0x15100a];
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const isPath = maze[z][x] === 0;
                    const groundHeight = isPath ? 0.0 : minGroundHeight + Math.random() * (maxGroundHeight - minGroundHeight);
                    const extrudeSettings = { depth: groundHeight, bevelEnabled: false };
                    const groundGeometry = new THREE.ExtrudeGeometry(groundShape, extrudeSettings);
                    const groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: isPath ? 0x3f2f1f : groundColors[Math.floor(Math.random() * groundColors.length)],
                        specular: 0x111111,
                        shininess: 5
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.set(x * tileSize + tileSize / 2, 0, z * tileSize + tileSize / 2);
                    scene.add(ground);

                    if (maze[z][x] === 1) {
                        const width = minTrunkWidth + Math.random() * (maxTrunkWidth - minTrunkWidth);
                        const height = minTrunkHeight + Math.random() * (maxTrunkHeight - minTrunkHeight);
                        const trunkColor = trunkColors[Math.floor(Math.random() * trunkColors.length)];
                        const treeMaterial = new THREE.MeshPhongMaterial({ 
                            color: trunkColor,
                            specular: 0x111111,
                            shininess: 5
                        });
                        const trunkPoints = [
                            new THREE.Vector2(0, 0),
                            new THREE.Vector2(width / 2, height * 0.3),
                            new THREE.Vector2(width / 2.5, height * 0.6),
                            new THREE.Vector2(width / 3, height * 0.9),
                            new THREE.Vector2(0, height)
                        ];
                        const treeGeometry = new THREE.LatheGeometry(trunkPoints, 12);
                        const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                        const treeX = x * tileSize + tileSize / 2;
                        const treeZ = z * tileSize + tileSize / 2;
                        tree.position.set(treeX, trunkOffsetY, treeZ);
                        scene.add(tree);

                        const canopySize = minCanopySize + Math.random() * (maxCanopySize - minCanopySize);
                        const canopyGeometry = new THREE.IcosahedronGeometry(canopySize / 2, 0);
                        const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
                        const canopyMaterial = new THREE.MeshPhongMaterial({ 
                            color: canopyColor,
                            specular: 0x111111,
                            shininess: 5,
                            side: THREE.DoubleSide
                        });
                        const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                        canopy.position.set(treeX, height + trunkOffsetY, treeZ);
                        scene.add(canopy);

                        trees.push({ x: treeX, z: treeZ, width: width });
                    }
                }
            }

            mainPath.forEach(p => {
                const isOptimal = optimalPath.some(op => op.x === p.x && op.z === p.z);
                if (isOptimal) {
                    const greenR = 31 + Math.floor(Math.random() * 16);
                    const greenG = 63 + Math.floor(Math.random() * 16);
                    const color = (greenR << 16) | (greenG << 8) | 31;
                    const stoneRadius = minPathStoneRadius + Math.random() * (maxPathStoneRadius - minPathStoneRadius);
                    const stoneGeometry = new THREE.CircleGeometry(stoneRadius, 32);
                    const stoneMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, shininess: 5 });
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.rotation.x = -Math.PI / 2;
                    stone.position.set(p.x * tileSize + tileSize / 2, 0.01, p.z * tileSize + tileSize / 2);
                    stone.visible = true;
                    stoneMeshes.push(stone);
                    scene.add(stone);
                }
            });

            const shardGeometry = new THREE.TetrahedronGeometry(tileSize / 4, 0);
            const shardMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff3399,
                transparent: true, 
                opacity: 0.7, 
                specular: 0x111111, 
                shininess: 5,
                emissive: 0xff3399,
                emissiveIntensity: 0
            });
            shards.forEach(shard => {
                const shardMesh = new THREE.Mesh(shardGeometry, shardMaterial);
                shardMesh.position.set(shard.x + tileSize / 2, tileSize / 4, shard.z + tileSize / 2);
                shard.mesh = shardMesh;
                scene.add(shardMesh);
            });

            const lightSourceGeometry = new THREE.OctahedronGeometry(tileSize / 6, 0);
            const lightSourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa55,
                transparent: true, 
                opacity: 0.7, 
                specular: 0x111111, 
                shininess: 5, 
                emissive: 0xffaa55, 
                emissiveIntensity: 0 
            });
            lightSources.forEach(light => {
                const lightMesh = new THREE.Mesh(lightSourceGeometry, lightSourceMaterial);
                lightMesh.position.set(light.x + tileSize / 2, tileSize / 4, light.z + tileSize / 2);
                light.mesh = lightMesh;
                scene.add(lightMesh);
            });

            const goalGeometry = new THREE.DodecahedronGeometry(tileSize / 2, 0);
            const goalMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x220033, 
                transparent: true, 
                opacity: 0.7, 
                specular: 0x111111, 
                shininess: 5, 
                emissive: 0x220033, 
                emissiveIntensity: 0 
            });
            const goalMesh = new THREE.Mesh(goalGeometry, goalMaterial);
            goalMesh.position.set(goal.x + tileSize / 2, tileSize / 2, goal.z + tileSize / 2);
            goal.mesh = goalMesh;
            scene.add(goalMesh);

            ghosts.forEach(ghost => scene.add(ghost.mesh));

            camera.position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            camera.rotation.set(0, 0, 0);

            if (optimalPath.length > 1) {
                const nextTile = optimalPath[1];
                const dx = (nextTile.x * tileSize + tileSize / 2) - camera.position.x;
                const dz = (nextTile.z * tileSize + tileSize / 2) - camera.position.z;
                const yaw = Math.atan2(dx, dz);
                controls.getObject().rotation.y = yaw;
            }

            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            sprint = false;
            shootBeam = false;
            flashlightPower = 100;
            stamina = maxStamina;
            flashlight.intensity = maxFlashlightIntensity;
            flashlight.distance = maxFlashlightDistance;
            gameOver = false;
            stonesVisible = true;
            ghostsEliminated = 0;
            hud.toggleStones.textContent = "Hide Path Stones";

            drawMinimap();
            updateHUD();

            console.log(`Maze generation complete - Size: ${mazeWidth}x${mazeHeight}, Shards: ${shards.length}, Lights: ${lightSources.length}, Ghosts: ${ghosts.length}, Scene objects: ${scene.children.length}`);
        }

        function canMoveTo(newX, newZ) {
            const tileX = Math.floor(newX / tileSize);
            const tileZ = Math.floor(newZ / tileSize);
            if (tileX < 0 || tileX >= mazeWidth || tileZ < 0 || tileZ >= mazeHeight || maze[tileZ][tileX] === 1) {
                return false;
            }

            const playerRadius = playerSize / 2;
            const playerCenterX = newX + playerRadius;
            const playerCenterZ = newZ + playerRadius;

            for (const tree of trees) {
                const treeRadius = tree.width / 2;
                const dx = playerCenterX - tree.x;
                const dz = playerCenterZ - tree.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < (playerRadius + treeRadius)) {
                    return false;
                }
            }

            return true;
        }

        function shootLightBeam() {
            const currentTime = Date.now();
            if (currentTime - lastBeamTime < beamCooldown || flashlightPower < 5 || gameOver) return;

            lastBeamTime = currentTime;
            flashlightPower -= 5;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const start = new THREE.Vector3(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            const beamGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const beamMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.copy(start);
            scene.add(beam);

            const velocity = direction.clone().multiplyScalar(0.1);
            const beamLifetime = 2000;
            const beamStartTime = currentTime;
            let beamActive = true;

            function animateBeam() {
                if (Date.now() - beamStartTime < beamLifetime && beamActive && !gameOver) {
                    beam.position.add(velocity);
                    ghosts.forEach(ghost => {
                        const ghostPos = new THREE.Vector3(ghost.x + tileSize / 2, tileSize / 2, ghost.z + tileSize / 2);
                        if (beam.position.distanceTo(ghostPos) < 0.5) {
                            ghost.health -= 25;
                            ghost.hitTime = Date.now();
                            ghost.mesh.material.color.setHex(0xff8800);
                            beamActive = false;
                            scene.remove(beam);
                            if (ghost.health <= 0) {
                                scene.remove(ghost.mesh);
                                ghosts = ghosts.filter(g => g !== ghost);
                                ghostsEliminated++;
                            }
                        }
                    });
                    if (beamActive) requestAnimationFrame(animateBeam);
                } else if (beamActive) {
                    scene.remove(beam);
                }
            }
            animateBeam();
        }

        function updateGhosts() {
            const currentTime = Date.now();
            ghosts.forEach(ghost => {
                const dx = player.x - ghost.spawnX;
                const dz = player.z - ghost.spawnZ;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < ghostAttackRange) {
                    const moveDx = player.x - ghost.x;
                    const moveDz = player.z - ghost.z;
                    const moveDistance = Math.sqrt(moveDx * moveDx + moveDz * moveDz);
                    if (moveDistance > 0) {
                        const directionX = moveDx / moveDistance;
                        const directionZ = moveDz / moveDistance;
                        ghost.x += directionX * ghost.speed;
                        ghost.z += directionZ * ghost.speed;
                    }

                    if (moveDistance < playerSize && currentTime - ghost.lastAttack > ghost.attackCooldown) {
                        player.health -= 10;
                        ghost.lastAttack = currentTime;
                        damageFlash.style.opacity = 0.5;
                        setTimeout(() => damageFlash.style.opacity = 0, 500);
                        if (player.health <= 0) {
                            gameOver = true;
                            gameOverMessage.textContent = "You were overwhelmed by ghosts!";
                            gameOverOverlay.style.display = 'block';
                            finalScoreSpan.textContent = score;
                            controls.unlock();
                        }
                    }
                }

                if (currentTime - ghost.hitTime > 500 && ghost.hitTime !== 0) {
                    ghost.mesh.material.color.setHex(0xaaaaaa);
                }
                ghost.mesh.position.set(ghost.x + tileSize / 2, tileSize / 2 + Math.sin(currentTime * 0.002) * 0.2, ghost.z + tileSize / 2);
            });
        }

        function toggleMinimap() {
            if (isMinimapExpanded) {
                minimapCanvas.style.width = '200px';
                minimapCanvas.style.height = '200px';
                minimapCanvas.style.top = '10px';
                minimapCanvas.style.right = '10px';
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = 200;
                minimapCanvas.height = 200;
            } else {
                const padding = 50;
                const mapWidth = Math.min(window.innerWidth - 2 * padding, mazeWidth * 20);
                const mapHeight = Math.min(window.innerHeight - 2 * padding, mazeHeight * 20);
                minimapCanvas.style.width = `${mapWidth}px`;
                minimapCanvas.style.height = `${mapHeight}px`;
                minimapCanvas.style.top = `${10}px`;
                minimapCanvas.style.right = `${10}px`;
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = mapWidth;
                minimapCanvas.height = mapHeight;
            }
            isMinimapExpanded = !isMinimapExpanded;
            drawMinimap();
        }

        function toggleStones() {
            stonesVisible = !stonesVisible;
            stoneMeshes.forEach(stone => stone.visible = stonesVisible);
            hud.toggleStones.textContent = stonesVisible ? "Hide Path Stones" : "Show Path Stones";
        }

        function revealMap() {
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    visitedTiles.add(`${x},${z}`);
                }
            }
            drawMinimap();
        }

        hud.toggleStones.addEventListener('click', toggleStones);
        hud.revealMap.addEventListener('click', revealMap);

        function update() {
            if (gameOver) return;


            const currentTime = Date.now();
            const deltaTime = 16;

            if (sprint && stamina > 0) {
                stamina -= deltaTime;
                if (stamina <= 0) sprint = false;
            } else if (!sprint && stamina < maxStamina) {
                stamina += staminaRecoveryRate * deltaTime;
                stamina = Math.min(stamina, maxStamina);
            }

            const velocity = new THREE.Vector3();
            if (moveForward || moveBackward || moveLeft || moveRight || moveJoystickActive) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const currentSpeed = sprint ? sprintSpeed : player.speed;
                if (moveForward) velocity.add(direction.clone().multiplyScalar(currentSpeed));
                if (moveBackward) velocity.sub(direction.clone().multiplyScalar(currentSpeed));
                const right = new THREE.Vector3();
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                if (moveLeft) velocity.sub(right.clone().multiplyScalar(currentSpeed));
                if (moveRight) velocity.add(right.clone().multiplyScalar(currentSpeed));

                if (moveJoystickActive) {
                    const joystickMagnitude = Math.sqrt(moveJoystickDeltaX * moveJoystickDeltaX + moveJoystickDeltaY * moveJoystickDeltaY);
                    if (joystickMagnitude > 0) {
                        const joystickDirX = moveJoystickDeltaX / joystickMagnitude;
                        const joystickDirY = moveJoystickDeltaY / joystickMagnitude;
                        const forwardComponent = direction.clone().multiplyScalar(-joystickDirY);
                        const rightComponent = right.clone().multiplyScalar(joystickDirX);
                        velocity.add(forwardComponent).add(rightComponent).normalize().multiplyScalar(currentSpeed * (joystickMagnitude / joystickRadius));
                    }
                }
            }

            if (cameraJoystickActive) {
                const rotateSpeed = navigator.maxTouchPoints > 0 ? 0.0015 : 0.005;
                controls.getObject().rotation.y -= cameraJoystickDeltaX * rotateSpeed;
            }

            if (velocity.length() > 0) {
                const moveX = velocity.x;
                const moveZ = velocity.z;

                let newX = player.x + moveX;
                let newZ = player.z;
                if (canMoveTo(newX, newZ)) player.x = newX;

                newX = player.x;
                newZ = player.z + moveZ;
                if (canMoveTo(newX, newZ)) player.z = newZ;

                controls.getObject().position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            }

            if (shootBeam) shootLightBeam();

            updateGhosts();

            shards.forEach(shard => {
                if (!shard.collected) {
                    shard.mesh.material.emissiveIntensity = (Math.sin(currentTime * 0.001 + shard.phase) + 1) / 2;
                    if (Math.abs(player.x - shard.x) < tileSize && Math.abs(player.z - shard.z) < tileSize) {
                        shard.collected = true;
                        score += 10 * (levelsCompleted + 1);
                        scene.remove(shard.mesh);
                    }
                }
            });

            const collectedShards = shards.filter(shard => shard.collected).length;
            const totalShards = shards.length;
            goal.mesh.material.emissiveIntensity = collectedShards / totalShards;
            const purpleValue = Math.floor(0x33 + (0xcc - 0x33) * (collectedShards / totalShards));
            goal.mesh.material.emissive.setHex((purpleValue << 16) | (0x00 << 8) | purpleValue);

            lightSources.forEach(light => {
                if (!light.collected) {
                    light.mesh.position.y = tileSize / 2 + Math.sin(currentTime * 0.002 + light.phase) * 0.1;
                    light.mesh.material.emissiveIntensity = (Math.sin(currentTime * 0.001 + light.phase) + 1) / 2;
                    if (Math.abs(player.x - light.x) < tileSize && Math.abs(player.z - light.z) < tileSize) {
                        light.collected = true;
                        scene.remove(light.mesh);
                        flashlightPower = Math.min(200, flashlightPower + 10);
                    }
                }
            });
            lightSources = lightSources.filter(light => !light.collected);

            if (flashlightPower > 0) {
                flashlightPower -= flashlightDrainRate / 60;
                flashlightPower = Math.max(0, flashlightPower);
                flashlight.intensity = maxFlashlightIntensity * Math.min(1, flashlightPower / 100);
                flashlight.distance = minFlashlightDistance + (maxFlashlightDistance - minFlashlightDistance) * Math.min(1, flashlightPower / 100);
                if (flashlightPower === 0) {
                    gameOver = true;
                    gameOverMessage.textContent = "Your flashlight ran out of power!";
                    gameOverOverlay.style.display = 'block';
                    finalScoreSpan.textContent = score;
                    controls.unlock();
                }
            }

            if (player.x !== player.lastX || player.z !== player.lastZ) {
                player.lastX = player.x;
                player.lastZ = player.z;
                drawMinimap();

                const tileX = Math.floor(player.x / tileSize);
                const tileZ = Math.floor(player.z / tileSize);
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = tileX + dx;
                        const nz = tileZ + dz;
                        if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                            visitedTiles.add(`${nx},${nz}`);
                        }
                    }
                }
            }

            if (Math.abs(player.x - goal.x) < tileSize && Math.abs(player.z - goal.z) < tileSize) {
                if (collectedShards === totalShards) {
                    levelsCompleted++;
                    score += 50 * levelsCompleted;
                    alert(`Level ${levelsCompleted} Completed! Total Score: ${score}`);
                    generateMaze();
                }
            }

            statusBars.healthBar.style.width = `${(player.health / 100) * 100}%`;
            statusBars.flashlightBar.style.width = `${(flashlightPower / 100) * 100}%`;
            statusBars.staminaBar.style.width = `${(stamina / maxStamina) * 100}%`;
        }

        function updateHUD() {
            hud.level.textContent = levelsCompleted + 1;
            hud.score.textContent = score;
            const totalShards = shards.length;
            const foundShards = shards.filter(s => s.collected).length;
            hud.shards.textContent = `${foundShards}/${totalShards} found`;
            hud.shardMessage.textContent = foundShards < totalShards ? `Find ${totalShards - foundShards} more shards to complete the level!` : "All shards collected!";
            const totalLights = lightSources.length + lightSources.filter(l => l.collected).length;
            const foundLights = lightSources.filter(l => l.collected).length;
            hud.lightSources.textContent = `${foundLights}/${totalLights} found`;
            hud.ghostsEliminated.textContent = ghostsEliminated;
            hud.controlsInfo.innerHTML = navigator.maxTouchPoints > 0 ?
                `<br>Controls:<br>${isJoystickSwapped ? 'Right' : 'Left'} Joystick: Move<br>${isJoystickSwapped ? 'Left' : 'Right'} Joystick: Turn<br>RUN Button: Sprint<br>ATK Button: Shoot<br>Spacebar: Toggle Map` :
                '<br>Controls:<br>WASD/Arrows: Move<br>Mouse: Look<br>Left-Click: Shoot<br>Shift: Sprint<br>Spacebar: Toggle Map';
        }

        function drawMinimap() {
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileZ = Math.floor(player.z / tileSize);
            const tileWidth = minimapCanvas.width / (isMinimapExpanded ? mazeWidth : 10);
            const tileHeight = minimapCanvas.height / (isMinimapExpanded ? mazeHeight : 10);

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            minimapCtx.save();
            minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2);
            minimapCtx.rotate(Math.PI);
            minimapCtx.translate(-minimapCanvas.width / 2, -minimapCanvas.height / 2);

            if (isMinimapExpanded) {
                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                minimapCtx.fillStyle = '#3f2f1f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                shards.forEach(shard => {
                    if (!shard.collected && visitedTiles.has(`${Math.floor(shard.x / tileSize)},${Math.floor(shard.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((shard.x / tileSize) * tileWidth, (shard.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    if (!light.collected && visitedTiles.has(`${Math.floor(light.x / tileSize)},${Math.floor(light.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((light.x / tileSize) * tileWidth, (light.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                ghosts.forEach(ghost => {
                    const ghostX = Math.floor(ghost.x / tileSize);
                    const ghostZ = Math.floor(ghost.z / tileSize);
                    if (visitedTiles.has(`${ghostX},${ghostZ}`)) {
                        minimapCtx.fillStyle = 'white';
                        minimapCtx.fillRect(ghostX * tileWidth, ghostZ * tileHeight, tileWidth, tileHeight);
                    }
                });

                minimapCtx.fillStyle = 'blue';
                minimapCtx.fillRect(goal.x / tileSize * tileWidth, goal.z / tileSize * tileHeight, tileWidth, tileHeight);
            } else {
                const minX = Math.max(0, playerTileX - 5);
                const maxX = Math.min(mazeWidth - 1, playerTileX + 4);
                const minZ = Math.max(0, playerTileZ - 5);
                const maxZ = Math.min(mazeHeight - 1, playerTileZ + 4);

                for (let z = minZ; z <= maxZ; z++) {
                    for (let x = minX; x <= maxX; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                minimapCtx.fillStyle = '#3f2f1f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                shards.forEach(shard => {
                    const shardX = Math.floor(shard.x / tileSize);
                    const shardZ = Math.floor(shard.z / tileSize);
                    if (!shard.collected && visitedTiles.has(`${shardX},${shardZ}`) && shardX >= minX && shardX <= maxX && shardZ >= minZ && shardZ <= maxZ) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((shardX - playerTileX + 5) * tileWidth, (shardZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    const lightX = Math.floor(light.x / tileSize);
                    const lightZ = Math.floor(light.z / tileSize);
                    if (!light.collected && visitedTiles.has(`${lightX},${lightZ}`) && lightX >= minX && lightX <= maxX && lightZ >= minZ && lightZ <= maxZ) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((lightX - playerTileX + 5) * tileWidth, (lightZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                ghosts.forEach(ghost => {
                    const ghostX = Math.floor(ghost.x / tileSize);
                    const ghostZ = Math.floor(ghost.z / tileSize);
                    if (visitedTiles.has(`${ghostX},${ghostZ}`) && ghostX >= minX && ghostX <= maxX && ghostZ >= minZ && ghostZ <= maxZ) {
                        minimapCtx.fillStyle = 'white';
                        minimapCtx.fillRect((ghostX - playerTileX + 5) * tileWidth, (ghostZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                const goalTileX = Math.floor(goal.x / tileSize);
                const goalTileZ = Math.floor(goal.z / tileSize);
                if (goalTileX >= minX && goalTileX <= maxX && goalTileZ >= minZ && goalTileZ <= maxZ) {
                    minimapCtx.fillStyle = 'blue';
                    minimapCtx.fillRect((goalTileX - playerTileX + 5) * tileWidth, (goalTileZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                }
            }

            minimapCtx.fillStyle = 'red';
            const playerMapX = isMinimapExpanded ? (playerTileX * tileWidth) : (5 * tileWidth);
            const playerMapZ = isMinimapExpanded ? (playerTileZ * tileHeight) : (5 * tileHeight);
            minimapCtx.fillRect(playerMapX, playerMapZ, tileWidth, tileHeight);

            minimapCtx.restore();
        }

        function resetGame() {
            gameOverOverlay.style.display = 'none';
            score = 0;
            levelsCompleted = 0;
            ghostsEliminated = 0;
            gameOver = false;
            generateMaze();
            if (navigator.maxTouchPoints > 0) {
                // Mobile: Prompt user to tap screen to lock controls
                console.log("Tap screen to start playing after restart");
                document.getElementById('gameCanvas').focus();
            } else {
                controls.lock();
            }
        }

        restartButton.addEventListener('click', (e) => {
            e.preventDefault();
            resetGame();
        });
        restartButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            resetGame();
        }, { passive: false });

        function gameLoop() {
            if (!renderer.getContext()) {
                console.error("WebGL not available");
            }
            update();
            renderer.render(scene, camera);
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        generateMaze();
        gameLoop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isMinimapExpanded) toggleMinimap();
        });
    </script>
</body>
</html>