<!DOCTYPE html>
<html>
<head>
    <title>Endless Maze Explorer 3D - Haunted Forest</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #gameCanvas { width: 100%; height: 100vh; }
        #minimap {
            border: 1px solid black;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            transition: all 0.5s ease;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #gameOverOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }
        #gameOverOverlay button, #swap-joysticks {
            padding: 5px 10px;
            font-size: 12px;
            margin-top: 5px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOverOverlay button:hover, #swap-joysticks:hover { background-color: #cc3333; }
        #joystick-move, #joystick-camera {
            position: absolute;
            bottom: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
            display: none;
        }
        #joystick-move { left: 20px; }
        #joystick-camera { right: 20px; }
        #joystick-move-knob, #joystick-camera-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <canvas id="minimap"></canvas>
    <div id="gameCanvas"></div>
    <div id="hud">
        Level: <span id="level">1</span><br>
        Score: <span id="score">0</span><br>
        Coins: <span id="coins">0</span><br>
        Light Sources: <span id="lightSources">0</span><br>
        Flashlight: <span id="flashlightMeter">100%</span><br>
        <div id="controls-info"></div>
        <button id="swap-joysticks" style="display: none;">Swap Joysticks</button>
    </div>
    <div id="gameOverOverlay">
        <h2>Game Over</h2>
        <p>Your flashlight ran out of power!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">Restart</button>
    </div>
    <div id="joystick-move">
        <div id="joystick-move-knob"></div>
    </div>
    <div id="joystick-camera">
        <div id="joystick-camera-knob"></div>
    </div>

    <script>
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;
        const hud = {
            level: document.getElementById('level'),
            score: document.getElementById('score'),
            coins: document.getElementById('coins'),
            lightSources: document.getElementById('lightSources'),
            flashlightMeter: document.getElementById('flashlightMeter'),
            controlsInfo: document.getElementById('controls-info'),
            swapJoysticks: document.getElementById('swap-joysticks')
        };
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreSpan = document.getElementById('finalScore');
        const joystickMove = document.getElementById('joystick-move');
        const joystickMoveKnob = document.getElementById('joystick-move-knob');
        const joystickCamera = document.getElementById('joystick-camera');
        const joystickCameraKnob = document.getElementById('joystick-camera-knob');

        // Touch detection and joystick setup
        let isJoystickSwapped = false;
        if (navigator.maxTouchPoints > 0) {
            joystickMove.style.display = 'block';
            joystickCamera.style.display = 'block';
            hud.swapJoysticks.style.display = 'block';
            hud.swapJoysticks.addEventListener('click', () => {
                isJoystickSwapped = !isJoystickSwapped;
                joystickMove.style.left = isJoystickSwapped ? 'auto' : '20px';
                joystickMove.style.right = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.left = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.right = isJoystickSwapped ? 'auto' : '20px';
            });
        }

        // Game variables
        const tileSize = 1;
        const playerSize = 0.3;
        let mazeWidth = 25;
        let mazeHeight = 25;
        const sizeIncrease = 5;
        let player = { x: tileSize, z: tileSize, speed: 0.05, lastX: tileSize, lastZ: tileSize };
        let goal = { x: 0, z: 0 };
        let maze = [];
        let trees = [];
        let coins = [];
        let lightSources = [];
        let score = 0;
        let levelsCompleted = 0;
        let mainPath = [];
        let deadEnds = [];
        let optimalPath = [];
        let flashlightPower = 100;
        const maxFlashlightIntensity = 2.5;
        const minFlashlightDistance = 1;
        const maxFlashlightDistance = 10;
        const flashlightDrainRate = 1;
        let gameOver = false;
        let visitedTiles = new Set();
        let isMinimapExpanded = false;

        // Geometry min-max variables
        const minGroundHeight = 0.0;
        const maxGroundHeight = 0.1;
        const minCanopySize = 0.9;
        const maxCanopySize = 1.2;
        const minTrunkWidth = 0.2;
        const maxTrunkWidth = 0.4;
        const minTrunkHeight = 1.2;
        const maxTrunkHeight = 2.2;
        const minPathStoneRadius = tileSize / 20;
        const maxPathStoneRadius = tileSize / 2;
        const pathWidth = 1;
        const trunkOffsetY = -0.7;

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('gameCanvas').appendChild(renderer.domElement);

        scene.fog = new THREE.Fog(0x000000, 8, 12);

        const flashlight = new THREE.SpotLight(0xaaaaaa, maxFlashlightIntensity, maxFlashlightDistance, Math.PI / 3, 0.9);
        flashlight.position.set(0, 0.5, 0);
        flashlight.target = new THREE.Object3D();
        flashlight.target.position.set(0, 0, -1);
        camera.add(flashlight);
        camera.add(flashlight.target);
        scene.add(camera);

        const debugSphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const debugSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const debugSphere = new THREE.Mesh(debugSphereGeometry, debugSphereMaterial);
        debugSphere.position.copy(flashlight.position);
        camera.add(debugSphere);

        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => controls.lock());

        // Keyboard controls
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            if (!gameOver) {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (!isMinimapExpanded) toggleMinimap(); break;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
                case 'Space': if (isMinimapExpanded) toggleMinimap(); break;
            }
        });

        // Joystick controls
        let moveJoystickActive = false, cameraJoystickActive = false;
        let moveJoystickDeltaX = 0, moveJoystickDeltaY = 0;
        let cameraJoystickDeltaX = 0, cameraJoystickDeltaY = 0;
        const joystickRadius = 50;

        function setupJoystick(joystickElement, knobElement, isMoveDefault) {
            const isMove = isJoystickSwapped ? !isMoveDefault : isMoveDefault;
            joystickElement.addEventListener('touchstart', (e) => {
                if (!gameOver && e.touches.length <= 2) {
                    const touch = e.touches[0];
                    const rect = joystickElement.getBoundingClientRect();
                    const centerX = rect.left + joystickRadius;
                    const centerY = rect.top + joystickRadius;
                    if (isMove) {
                        moveJoystickActive = true;
                        moveJoystickDeltaX = touch.clientX - centerX;
                        moveJoystickDeltaY = touch.clientY - centerY;
                    } else {
                        cameraJoystickActive = true;
                        cameraJoystickDeltaX = touch.clientX - centerX;
                        cameraJoystickDeltaY = touch.clientY - centerY;
                    }
                    updateJoystickPosition(knobElement, touch.clientX, touch.clientY, rect);
                    e.preventDefault();
                }
            });

            joystickElement.addEventListener('touchmove', (e) => {
                if (!gameOver && e.touches.length <= 2) {
                    const touch = e.touches[isMove && moveJoystickActive ? 0 : 1] || e.touches[0];
                    const rect = joystickElement.getBoundingClientRect();
                    const centerX = rect.left + joystickRadius;
                    const centerY = rect.top + joystickRadius;
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > joystickRadius) {
                        dx = dx * joystickRadius / distance;
                        dy = dy * joystickRadius / distance;
                    }
                    if (isMove) {
                        moveJoystickDeltaX = dx;
                        moveJoystickDeltaY = dy;
                    } else {
                        cameraJoystickDeltaX = dx;
                        cameraJoystickDeltaY = dy;
                    }
                    updateJoystickPosition(knobElement, centerX + dx, centerY + dy, rect);
                    e.preventDefault();
                }
            });

            joystickElement.addEventListener('touchend', (e) => {
                if (!gameOver) {

                    if (isMove) {
                        moveJoystickActive = false;
                        moveJoystickDeltaX = 0;
                        moveJoystickDeltaY = 0;
                    } else {
                        cameraJoystickActive = false;
                        cameraJoystickDeltaX = 0;
                        cameraJoystickDeltaY = 0;
                    }
                    knobElement.style.left = '50%';
                    knobElement.style.top = '50%';
                    e.preventDefault();
                }
            });
        }

        function updateJoystickPosition(knob, x, y, rect) {
            const knobX = x - rect.left - 20;
            const knobY = y - rect.top - 20;
            knob.style.left = `${knobX}px`;
            knob.style.top = `${knobY}px`;
        }

        setupJoystick(joystickMove, joystickMoveKnob, true);
        setupJoystick(joystickCamera, joystickCameraKnob, false);

        // Maze generation with optimal path
        function generateMaze() {
            mazeWidth = 25 + sizeIncrease * levelsCompleted;
            mazeHeight = 25 + sizeIncrease * levelsCompleted;
            const groundBuffer = Math.floor(Math.max(0, levelsCompleted - 4) / 5);

            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1);
                }
                maze.push(row);
            }

            const stack = [];
            let startX = 1 + groundBuffer;
            let startZ = 1 + groundBuffer;
            let goalX = mazeWidth - 2 - groundBuffer;
            let goalZ = mazeHeight - 2 - groundBuffer;

            maze[startZ][startX] = 0;
            stack.push({ x: startX, z: startZ });

            function carvePath(x, z) {
                const directions = [
                    { dx: 2, dz: 0 }, { dx: -2, dz: 0 },
                    { dx: 0, dz: 2 }, { dx: 0, dz: -2 }
                ].sort(() => Math.random() - 0.5);

                for (const dir of directions) {
                    const newX = x + dir.dx;
                    const newZ = z + dir.dz;

                    if (newX > groundBuffer && newX < mazeWidth - groundBuffer - 1 &&
                        newZ > groundBuffer && newZ < mazeHeight - groundBuffer - 1 &&
                        maze[newZ][newX] === 1) {
                        maze[newZ - dir.dz / 2][newX - dir.dx / 2] = 0;
                        maze[newZ][newX] = 0;
                        stack.push({ x: newX, z: newZ });
                        carvePath(newX, newZ);
                    }
                }
            }

            carvePath(startX, startZ);
            maze[goalZ][goalX] = 0;

            // Find optimal path using BFS
            function findOptimalPath() {
                const queue = [{ x: startX, z: startZ, path: [{ x: startX, z: startZ }] }];
                const visited = new Set([`${startX},${startZ}`]);
                const directions = [
                    { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
                    { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
                ];

                while (queue.length > 0) {
                    const { x, z, path } = queue.shift();
                    if (x === goalX && z === goalZ) return path;

                    for (const dir of directions) {
                        const newX = x + dir.dx;
                        const newZ = z + dir.dz;
                        const key = `${newX},${newZ}`;
                        if (newX >= 0 && newX < mazeWidth && newZ >= 0 && newZ < mazeHeight &&
                            maze[newZ][newX] === 0 && !visited.has(key)) {
                            visited.add(key);
                            queue.push({ x: newX, z: newZ, path: [...path, { x: newX, z: newZ }] });
                        }
                    }
                }
                return [];
            }

            mainPath = [];
            deadEnds = [];
            const pathSet = new Set();
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        mainPath.push({ x, z });
                        pathSet.add(`${x},${z}`);
                    }
                }
            }

            const targetDeadEnds = 5 + levelsCompleted;
            for (let i = 0; i < targetDeadEnds; i++) {
                let attempts = 0;
                while (attempts < 100) {
                    const startIdx = Math.floor(Math.random() * mainPath.length);
                    const { x, z } = mainPath[startIdx];
                    const directions = [
                        { dx: 2, dz: 0 }, { dx: -2, dz: 0 },
                        { dx: 0, dz: 2 }, { dx: 0, dz: -2 }
                    ];
                    const dir = directions[Math.floor(Math.random() * 4)];
                    const endX = x + dir.dx * 2;
                    const endZ = z + dir.dz * 2;
                    const midX = x + dir.dx / 2;
                    const midZ = z + dir.dz / 2;
                    if (endX > groundBuffer && endX < mazeWidth - groundBuffer - 1 &&
                        endZ > groundBuffer && endZ < mazeHeight - groundBuffer - 1 &&
                        maze[endZ][endX] === 1 && !pathSet.has(`${endX},${endZ}`) &&
                        maze[midZ][midX] === 1 && !pathSet.has(`${midX},${midZ}`)) {
                        maze[midZ][midX] = 0;
                        maze[endZ][endX] = 0;
                        deadEnds.push({ x: endX, z: endZ });
                        mainPath.push({ x: midX, z: midZ }, { x: endX, z: endZ });
                        pathSet.add(`${midX},${midZ}`);
                        pathSet.add(`${endX},${endZ}`);
                        break;
                    }
                    attempts++;
                }
            }

            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        for (let dz = -groundBuffer; dz <= groundBuffer; dz++) {
                            for (let dx = -groundBuffer; dx <= groundBuffer; dx++) {
                                const nx = x + dx;
                                const nz = z + dz;
                                if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight &&
                                    maze[nz][nx] === 1) {
                                    maze[nz][nx] = 2;
                                }
                            }
                        }
                    }
                }
            }

            optimalPath = findOptimalPath();

            player.x = startX * tileSize;
            player.z = startZ * tileSize;
            player.lastX = player.x;
            player.lastZ = player.z;
            goal.x = goalX * tileSize;
            goal.z = goalZ * tileSize;

            // Coins on ground tiles with 3 walls
            coins = [];
            for (let z = 1; z < mazeHeight - 1; z++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    if (maze[z][x] === 2) {
                        let wallCount = 0;
                        if (maze[z][x-1] === 1) wallCount++;
                        if (maze[z][x+1] === 1) wallCount++;
                        if (maze[z-1][x] === 1) wallCount++;
                        if (maze[z+1][x] === 1) wallCount++;
                        if (wallCount === 3) {
                            coins.push({ x: x * tileSize, z: z * tileSize, collected: false });
                        }
                    }
                }
            }

            // Lights every 5 tiles on optimal path
            lightSources = [];
            for (let i = 0; i < optimalPath.length; i += 5) {
                const p = optimalPath[i];
                lightSources.push({ x: p.x * tileSize, z: p.z * tileSize, collected: false });
            }

            // Clear previous level data
            trees = [];
            visitedTiles = new Set();
            visitedTiles.add(`${startX},${startZ}`);

            while (scene.children.length > 1) {
                scene.remove(scene.children[1]);
            }

            const groundShape = new THREE.Shape();
            groundShape.moveTo(-tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, -tileSize / 2);
            const groundColors = [0x4f2f1f, 0x2f4f2f, 0x4f4f1f];
            const canopyColors = [0x1f3f1f, 0x3f2f1f, 0x3f3f1f];
            const trunkColors = [0x2a1f15, 0x1f150f, 0x15100a];
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const isPath = maze[z][x] === 0;
                    const groundHeight = isPath ? 0.0 : minGroundHeight + Math.random() * (maxGroundHeight - minGroundHeight);
                    const extrudeSettings = { depth: groundHeight, bevelEnabled: false };
                    const groundGeometry = new THREE.ExtrudeGeometry(groundShape, extrudeSettings);
                    const groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: groundColors[Math.floor(Math.random() * groundColors.length)],
                        specular: 0x111111,
                        shininess: 5
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.set(x * tileSize + tileSize / 2, 0, z * tileSize + tileSize / 2);
                    scene.add(ground);

                    if (maze[z][x] === 1) {
                        const width = minTrunkWidth + Math.random() * (maxTrunkWidth - minTrunkWidth);
                        const height = minTrunkHeight + Math.random() * (maxTrunkHeight - minTrunkHeight);
                        const trunkColor = trunkColors[Math.floor(Math.random() * trunkColors.length)];
                        const treeMaterial = new THREE.MeshPhongMaterial({ 
                            color: trunkColor,
                            specular: 0x111111,
                            shininess: 5
                        });
                        const trunkPoints = [
                            new THREE.Vector2(0, 0),
                            new THREE.Vector2(width / 2, height * 0.3),
                            new THREE.Vector2(width / 2.5, height * 0.6),
                            new THREE.Vector2(width / 3, height * 0.9),
                            new THREE.Vector2(0, height)
                        ];
                        const treeGeometry = new THREE.LatheGeometry(trunkPoints, 12);
                        const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                        const treeX = x * tileSize + tileSize / 2;
                        const treeZ = z * tileSize + tileSize / 2;
                        tree.position.set(treeX, trunkOffsetY, treeZ);
                        scene.add(tree);

                        const canopySize = minCanopySize + Math.random() * (maxCanopySize - minCanopySize);
                        const canopyGeometry = new THREE.IcosahedronGeometry(canopySize / 2, 0);
                        const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
                        const canopyMaterial = new THREE.MeshPhongMaterial({ 
                            color: canopyColor,
                            specular: 0x111111,
                            shininess: 5,
                            side: THREE.DoubleSide
                        });
                        const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                        canopy.position.set(treeX, height + trunkOffsetY, treeZ);
                        scene.add(canopy);

                        trees.push({ x: treeX, z: treeZ, width: width });
                    }
                }
            }

            // Stones only on optimal path
            mainPath.forEach(p => {
                const isOptimal = optimalPath.some(op => op.x === p.x && op.z === p.z);
                if (isOptimal) {
                    const greenR = 31 + Math.floor(Math.random() * 16);
                    const greenG = 63 + Math.floor(Math.random() * 16);
                    const color = (greenR << 16) | (greenG << 8) | 31;
                    const stoneRadius = minPathStoneRadius + Math.random() * (maxPathStoneRadius - minPathStoneRadius);
                    const stoneGeometry = new THREE.CircleGeometry(stoneRadius, 32);
                    const stoneMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, shininess: 5 });
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.rotation.x = -Math.PI / 2;
                    stone.position.set(p.x * tileSize + tileSize / 2, 0.01, p.z * tileSize + tileSize / 2);
                    scene.add(stone);
                }
            });

            const coinGeometry = new THREE.TetrahedronGeometry(tileSize / 4, 0);
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffaa, specular: 0x111111, shininess: 5 });
            coins.forEach(coin => {
                const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
                coinMesh.position.set(coin.x + tileSize / 2, tileSize / 4, coin.z + tileSize / 2);
                coin.mesh = coinMesh;
                scene.add(coinMesh);
            });

            const lightSourceGeometry = new THREE.OctahedronGeometry(tileSize / 6, 0);
            const lightSourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa55, specular: 0x111111, shininess: 5, emissive: 0xffaa55, emissiveIntensity: 0 
            });
            lightSources.forEach(light => {
                const lightMesh = new THREE.Mesh(lightSourceGeometry, lightSourceMaterial);
                lightMesh.position.set(light.x + tileSize / 2, tileSize / 4, light.z + tileSize / 2);
                light.mesh = lightMesh;
                scene.add(lightMesh);
            });

            const goalGeometry = new THREE.DodecahedronGeometry(tileSize / 2, 0);
            const goalMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff, specular: 0x111111, shininess: 5 });
            const goalMesh = new THREE.Mesh(goalGeometry, goalMaterial);
            goalMesh.position.set(goal.x + tileSize / 2, tileSize / 2, goal.z + tileSize / 2);
            goal.mesh = goalMesh;
            scene.add(goalMesh);

            camera.position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            camera.rotation.x = 0; // Reset pitch
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            flashlightPower = 100;
            flashlight.intensity = maxFlashlightIntensity;
            flashlight.distance = maxFlashlightDistance;
            gameOver = false;

            drawMinimap();
            updateHUD();

            console.log(`Maze generated - Size: ${mazeWidth}x${mazeHeight}, Optimal path: ${optimalPath.length}, Coins: ${coins.length}, Lights: ${lightSources.length}`);
        }

        // Updated collision check
        function canMoveTo(newX, newZ) {
            const tileX = Math.floor(newX / tileSize);
            const tileZ = Math.floor(newZ / tileSize);
            if (tileX < 0 || tileX >= mazeWidth || tileZ < 0 || tileZ >= mazeHeight || maze[tileZ][tileX] === 1) {
                return false;
            }

            const playerRadius = playerSize / 2;
            const playerCenterX = newX + playerRadius;
            const playerCenterZ = newZ + playerRadius;

            for (const tree of trees) {
                const treeRadius = tree.width / 2;
                const dx = playerCenterX - tree.x;
                const dz = playerCenterZ - tree.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < (playerRadius + treeRadius)) {
                    return false;
                }
            }

            return true;
        }

        // Toggle minimap expansion from top-right
        function toggleMinimap() {
            if (isMinimapExpanded) {
                minimapCanvas.style.width = '200px';
                minimapCanvas.style.height = '200px';
                minimapCanvas.style.top = '10px';
                minimapCanvas.style.right = '10px';
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = 200;
                minimapCanvas.height = 200;
            } else {
                const padding = 50;
                const mapWidth = Math.min(window.innerWidth - 2 * padding, mazeWidth * 20);
                const mapHeight = Math.min(window.innerHeight - 2 * padding, mazeHeight * 20);
                minimapCanvas.style.width = `${mapWidth}px`;
                minimapCanvas.style.height = `${mapHeight}px`;
                minimapCanvas.style.top = `${10}px`;
                minimapCanvas.style.right = `${10}px`;
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = mapWidth;
                minimapCanvas.height = mapHeight;
            }
            isMinimapExpanded = !isMinimapExpanded;
            drawMinimap();
        }

        // Update game state
        function update() {
            if (gameOver) return;

            const velocity = new THREE.Vector3();
            if (moveForward || moveBackward || moveLeft || moveRight || moveJoystickActive) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                if (moveForward) velocity.add(direction.clone().multiplyScalar(player.speed));
                if (moveBackward) velocity.sub(direction.clone().multiplyScalar(player.speed));
                const right = new THREE.Vector3();
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                if (moveLeft) velocity.sub(right.clone().multiplyScalar(player.speed));
                if (moveRight) velocity.add(right.clone().multiplyScalar(player.speed));

                if (moveJoystickActive) {
                    const joystickMagnitude = Math.sqrt(moveJoystickDeltaX * moveJoystickDeltaX + moveJoystickDeltaY * moveJoystickDeltaY);
                    if (joystickMagnitude > 0) {
                        const joystickDirX = moveJoystickDeltaX / joystickMagnitude;
                        const joystickDirY = moveJoystickDeltaY / joystickMagnitude;
                        const forwardComponent = direction.clone().multiplyScalar(-joystickDirY);
                        const rightComponent = right.clone().multiplyScalar(joystickDirX);
                        velocity.add(forwardComponent).add(rightComponent).normalize().multiplyScalar(player.speed * (joystickMagnitude / joystickRadius));
                    }
                }
            }

            if (cameraJoystickActive) {
                const rotateSpeed = 0.005;
                controls.getObject().rotation.y -= cameraJoystickDeltaX * rotateSpeed; // Left/right yaw
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - cameraJoystickDeltaY * rotateSpeed)); // Up/down pitch
            }

            if (velocity.length() > 0) {
                const moveX = velocity.x;
                const moveZ = velocity.z;

                let newX = player.x + moveX;
                let newZ = player.z;
                if (canMoveTo(newX, newZ)) player.x = newX;

                newX = player.x;
                newZ = player.z + moveZ;
                if (canMoveTo(newX, newZ)) player.z = newZ;

                controls.getObject().position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            }

            coins.forEach(coin => {
                if (!coin.collected && Math.abs(player.x - coin.x) < tileSize && Math.abs(player.z - coin.z) < tileSize) {
                    coin.collected = true;
                    score += 10 * (levelsCompleted + 1);
                    scene.remove(coin.mesh);
                }
            });
            coins = coins.filter(coin => !coin.collected);

            lightSources.forEach(light => {
                if (!light.collected && Math.abs(player.x - light.x) < tileSize && Math.abs(player.z - light.z) < tileSize) {
                    light.collected = true;
                    scene.remove(light.mesh);
                    flashlightPower = Math.min(200, flashlightPower + 10);
                }
            });
            lightSources = lightSources.filter(light => !light.collected);

            if (flashlightPower > 0) {
                flashlightPower -= flashlightDrainRate / 60;
                flashlightPower = Math.max(0, flashlightPower);
                flashlight.intensity = maxFlashlightIntensity * Math.min(1, flashlightPower / 100);
                flashlight.distance = minFlashlightDistance + (maxFlashlightDistance - minFlashlightDistance) * Math.min(1, flashlightPower / 100);
                if (flashlightPower === 0) {
                    gameOver = true;
                    gameOverOverlay.style.display = 'block';
                    finalScoreSpan.textContent = score;
                    controls.unlock();
                }
            }

            const pulse = (Math.sin(Date.now() * 0.002) + 1) / 2;
            lightSources.forEach(light => {
                if (!light.collected && light.mesh) light.mesh.material.emissiveIntensity = pulse;
            });

            if (player.x !== player.lastX || player.z !== player.lastZ) {
                player.lastX = player.x;
                player.lastZ = player.z;
                drawMinimap();

                const tileX = Math.floor(player.x / tileSize);
                const tileZ = Math.floor(player.z / tileSize);
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = tileX + dx;
                        const nz = tileZ + dz;
                        if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                            visitedTiles.add(`${nx},${nz}`);
                        }
                    }
                }
            }

            if (Math.abs(player.x - goal.x) < tileSize && Math.abs(player.z - goal.z) < tileSize) {
                levelsCompleted++;
                score += 50 * levelsCompleted;
                alert(`Level ${levelsCompleted} Completed! Total Score: ${score}`);
                generateMaze();
            }
        }

        // Update HUD with controls
        function updateHUD() {
            hud.level.textContent = levelsCompleted + 1;
            hud.score.textContent = score;
            hud.coins.textContent = coins.filter(c => !c.collected).length;
            hud.lightSources.textContent = lightSources.filter(l => !l.collected).length;
            hud.flashlightMeter.textContent = `${Math.floor(flashlightPower)}%`;
            hud.controlsInfo.innerHTML = navigator.maxTouchPoints > 0 ?
                `<br>Controls:<br>${isJoystickSwapped ? 'Right' : 'Left'} Joystick: Move<br>${isJoystickSwapped ? 'Left' : 'Right'} Joystick: Look<br>Spacebar: Toggle Map` :
                '<br>Controls:<br>WASD/Arrows: Move<br>Mouse: Look<br>Spacebar: Toggle Map';
        }

        // Draw minimap with 180-degree rotation
        function drawMinimap() {
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileZ = Math.floor(player.z / tileSize);
            const tileWidth = minimapCanvas.width / (isMinimapExpanded ? mazeWidth : 10);
            const tileHeight = minimapCanvas.height / (isMinimapExpanded ? mazeHeight : 10);

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            minimapCtx.save();
            minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2);
            minimapCtx.rotate(Math.PI);
            minimapCtx.translate(-minimapCanvas.width / 2, -minimapCanvas.height / 2);

            if (isMinimapExpanded) {
                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                const isOptimal = optimalPath.some(op => op.x === x && op.z === z);
                                minimapCtx.fillStyle = isOptimal ? '#2f4f2f' : '#a0a0a0';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    if (!coin.collected && visitedTiles.has(`${Math.floor(coin.x / tileSize)},${Math.floor(coin.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coin.x / tileSize) * tileWidth, (coin.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    if (!light.collected && visitedTiles.has(`${Math.floor(light.x / tileSize)},${Math.floor(light.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((light.x / tileSize) * tileWidth, (light.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                minimapCtx.fillStyle = 'blue';
                minimapCtx.fillRect(goal.x / tileSize * tileWidth, goal.z / tileSize * tileHeight, tileWidth, tileHeight);
            } else {
                const minX = Math.max(0, playerTileX - 5);
                const maxX = Math.min(mazeWidth - 1, playerTileX + 4);
                const minZ = Math.max(0, playerTileZ - 5);
                const maxZ = Math.min(mazeHeight - 1, playerTileZ + 4);

                for (let z = minZ; z <= maxZ; z++) {
                    for (let x = minX; x <= maxX; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                const isOptimal = optimalPath.some(op => op.x === x && op.z === z);
                                minimapCtx.fillStyle = isOptimal ? '#2f4f2f' : '#a0a0a0';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    const coinX = Math.floor(coin.x / tileSize);
                    const coinZ = Math.floor(coin.z / tileSize);
                    if (!coin.collected && visitedTiles.has(`${coinX},${coinZ}`) && coinX >= minX && coinX <= maxX && coinZ >= minZ && coinZ <= maxZ) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coinX - playerTileX + 5) * tileWidth, (coinZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    const lightX = Math.floor(light.x / tileSize);
                    const lightZ = Math.floor(light.z / tileSize);
                    if (!light.collected && visitedTiles.has(`${lightX},${lightZ}`) && lightX >= minX && lightX <= maxX && lightZ >= minZ && lightZ <= maxZ) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((lightX - playerTileX + 5) * tileWidth, (lightZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                const goalTileX = Math.floor(goal.x / tileSize);
                const goalTileZ = Math.floor(goal.z / tileSize);
                if (goalTileX >= minX && goalTileX <= maxX && goalTileZ >= minZ && goalTileZ <= maxZ) {
                    minimapCtx.fillStyle = 'blue';
                    minimapCtx.fillRect((goalTileX - playerTileX + 5) * tileWidth, (goalTileZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                }
            }

            minimapCtx.fillStyle = 'red';
            const playerMapX = isMinimapExpanded ? (playerTileX * tileWidth) : (5 * tileWidth);
            const playerMapZ = isMinimapExpanded ? (playerTileZ * tileHeight) : (5 * tileHeight);
            minimapCtx.fillRect(playerMapX, playerMapZ, tileWidth, tileHeight);

            minimapCtx.restore();
        }

        // Reset game
        function resetGame() {
            gameOverOverlay.style.display = 'none';
            score = 0;
            levelsCompleted = 0;
            generateMaze();
            controls.lock();
        }

        // Game loop
        function gameLoop() {
            update();
            renderer.render(scene, camera);
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        generateMaze();
        gameLoop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isMinimapExpanded) toggleMinimap();
        });
    </script>
</body>
</html>