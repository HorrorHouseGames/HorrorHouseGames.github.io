<!DOCTYPE html>
<html>
<head>
    <title>Endless Maze Explorer 3D - Haunted Forest</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #gameCanvas { width: 100%; height: 100vh; }
        #minimap {
            border: 1px solid black;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            transition: all 0.5s ease;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #gameOverOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }
        #gameOverOverlay button {
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 20px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOverOverlay button:hover { background-color: #cc3333; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <canvas id="minimap"></canvas>
    <div id="gameCanvas"></div>
    <div id="hud">
        Level: <span id="level">1</span><br>
        Score: <span id="score">0</span><br>
        Coins: <span id="coins">0</span><br>
        Light Sources: <span id="lightSources">0</span><br>
        Flashlight: <span id="flashlightMeter">100%</span>
    </div>
    <div id="gameOverOverlay">
        <h2>Game Over</h2>
        <p>Your flashlight ran out of power!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">Restart</button>
    </div>

    <script>
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;
        const hud = {
            level: document.getElementById('level'),
            score: document.getElementById('score'),
            coins: document.getElementById('coins'),
            lightSources: document.getElementById('lightSources'),
            flashlightMeter: document.getElementById('flashlightMeter')
        };
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreSpan = document.getElementById('finalScore');

        // Game variables
        const tileSize = 1;
        const playerSize = 0.4;
        let mazeWidth = 25;
        let mazeHeight = 25;
        const sizeIncrease = 5;
        let player = { x: tileSize, z: tileSize, speed: 0.05, lastX: tileSize, lastZ: tileSize };
        let goal = { x: 0, z: 0 };
        let maze = [];
        let trees = [];
        let coins = [];
        let lightSources = [];
        let score = 0;
        let levelsCompleted = 0;
        let mainPath = [];
        let deadEnds = [];
        let flashlightPower = 100;
        const maxFlashlightIntensity = 2.5;
        const minFlashlightDistance = 1;
        const maxFlashlightDistance = 10;
        const flashlightDrainRate = 1;
        let gameOver = false;
        let visitedTiles = new Set();
        let isMinimapExpanded = false;

        // Geometry min-max variables (updated defaults)
        const minGroundHeight = 0.0;
        const maxGroundHeight = 0.1;
        const minCanopySize = 0.9;
        const maxCanopySize = 1.2;
        const minTrunkWidth = 0.2;
        const maxTrunkWidth = 0.4;
        const minTrunkHeight = 1.2;
        const maxTrunkHeight = 2.2;
        const minPathStoneRadius = tileSize / 20;
        const maxPathStoneRadius = tileSize / 2;
        const pathWidth = 1;
        const trunkOffsetY = -0.7;

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('gameCanvas').appendChild(renderer.domElement);

        scene.fog = new THREE.Fog(0x000000, 8, 12);

        const flashlight = new THREE.SpotLight(0xaaaaaa, maxFlashlightIntensity, maxFlashlightDistance, Math.PI / 3, 0.9);
        flashlight.position.set(0, 0.5, 0);
        flashlight.target = new THREE.Object3D();
        flashlight.target.position.set(0, 0, -1);
        camera.add(flashlight);
        camera.add(flashlight.target);
        scene.add(camera);

        const debugSphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const debugSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const debugSphere = new THREE.Mesh(debugSphereGeometry, debugSphereMaterial);
        debugSphere.position.copy(flashlight.position);
        camera.add(debugSphere);

        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => controls.lock());

        // Movement controls (WASD and Arrow keys)
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            if (!gameOver) {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (!isMinimapExpanded) toggleMinimap(); break;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
                case 'Space': if (isMinimapExpanded) toggleMinimap(); break;
            }
        });

        // Mobile touch controls
        let touchStartX = null, touchStartY = null;
        let touchDeltaX = 0, touchDeltaY = 0;
        let isTouching = false;

        document.addEventListener('touchstart', (e) => {
            if (!gameOver && e.touches.length === 1) {
                isTouching = true;
                moveForward = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (!gameOver && isTouching && e.touches.length === 1) {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                touchDeltaX = touchX - touchStartX;
                touchDeltaY = touchY - touchStartY;

                controls.getObject().rotation.y -= touchDeltaX * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - touchDeltaY * 0.005));

                touchStartX = touchX;
                touchStartY = touchY;
            }
        });

        document.addEventListener('touchend', (e) => {
            if (!gameOver) {
                isTouching = false;
                moveForward = false;
                controls.getObject().rotation.y = 0;
                camera.rotation.x = 0;
                touchDeltaX = 0;
                touchDeltaY = 0;
            }
        });

        // Maze generation with single path and dead ends
        function generateMaze() {
            mazeWidth = 25 + sizeIncrease * levelsCompleted;
            mazeHeight = 25 + sizeIncrease * levelsCompleted;
            const groundBuffer = Math.floor(Math.max(0, levelsCompleted - 4) / 5);

            // Initialize maze with walls (1 = wall, 0 = path, 2 = ground buffer)
            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1); // All walls initially
                }
                maze.push(row);
            }

            const stack = [];
            let startX = 1 + groundBuffer;
            let startZ = 1 + groundBuffer;
            let goalX = mazeWidth - 2 - groundBuffer;
            let goalZ = mazeHeight - 2 - groundBuffer;

            maze[startZ][startX] = 0; // Start point
            stack.push({ x: startX, z: startZ });

            function carvePath(x, z) {
                const directions = [
                    { dx: 2, dz: 0 }, // Right
                    { dx: -2, dz: 0 }, // Left
                    { dx: 0, dz: 2 }, // Down
                    { dx: 0, dz: -2 } // Up
                ].sort(() => Math.random() - 0.5); // Shuffle for randomness

                for (const dir of directions) {
                    const newX = x + dir.dx;
                    const newZ = z + dir.dz;

                    if (newX > groundBuffer && newX < mazeWidth - groundBuffer - 1 &&
                        newZ > groundBuffer && newZ < mazeHeight - groundBuffer - 1 &&
                        maze[newZ][newX] === 1) {
                        maze[newZ - dir.dz / 2][newX - dir.dx / 2] = 0; // Carve between
                        maze[newZ][newX] = 0;
                        stack.push({ x: newX, z: newZ });
                        carvePath(newX, newZ);
                    }
                }
            }

            // Carve single path
            carvePath(startX, startZ);
            maze[goalZ][goalX] = 0; // Ensure goal is on path

            // Extract main path and dead ends
            mainPath = [];
            deadEnds = [];
            const pathSet = new Set();
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        mainPath.push({ x, z });
                        pathSet.add(`${x},${z}`);
                    }
                }
            }

            // Add dead ends without crossing
            const targetDeadEnds = 5 + levelsCompleted;
            for (let i = 0; i < targetDeadEnds; i++) {
                let attempts = 0;
                while (attempts < 100) {
                    const startIdx = Math.floor(Math.random() * mainPath.length);
                    const { x, z } = mainPath[startIdx];
                    const directions = [
                        { dx: 2, dz: 0 }, { dx: -2, dz: 0 },
                        { dx: 0, dz: 2 }, { dx: 0, dz: -2 }
                    ];
                    const dir = directions[Math.floor(Math.random() * 4)];
                    const endX = x + dir.dx * 2;
                    const endZ = z + dir.dz * 2;
                    const midX = x + dir.dx / 2;
                    const midZ = z + dir.dz / 2;
                    if (endX > groundBuffer && endX < mazeWidth - groundBuffer - 1 &&
                        endZ > groundBuffer && endZ < mazeHeight - groundBuffer - 1 &&
                        maze[endZ][endX] === 1 && !pathSet.has(`${endX},${endZ}`) &&
                        maze[midZ][midX] === 1 && !pathSet.has(`${midX},${midZ}`)) {
                        maze[midZ][midX] = 0;
                        maze[endZ][endX] = 0;
                        deadEnds.push({ x: endX, z: endZ });
                        mainPath.push({ x: midX, z: midZ }, { x: endX, z: endZ });
                        pathSet.add(`${midX},${midZ}`);
                        pathSet.add(`${endX},${endZ}`);
                        break;
                    }
                    attempts++;
                }
            }

            // Set ground buffer around path
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        for (let dz = -groundBuffer; dz <= groundBuffer; dz++) {
                            for (let dx = -groundBuffer; dx <= groundBuffer; dx++) {
                                const nx = x + dx;
                                const nz = z + dz;
                                if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight &&
                                    maze[nz][nx] === 1) {
                                    maze[nz][nx] = 2; // Ground buffer
                                }
                            }
                        }
                    }
                }
            }

            player.x = startX * tileSize;
            player.z = startZ * tileSize;
            player.lastX = player.x;
            player.lastZ = player.z;
            goal.x = goalX * tileSize;
            goal.z = goalZ * tileSize;

            coins = deadEnds.map(de => ({ x: de.x * tileSize, z: de.z * tileSize, collected: false }));
            lightSources = [];
            for (let i = 0; i < mainPath.length; i += Math.floor(Math.random() * 6) + 5) {
                const p = mainPath[i];
                if (!deadEnds.some(de => de.x === p.x && de.z === p.z)) {
                    lightSources.push({ x: p.x * tileSize, z: p.z * tileSize, collected: false });
                }
            }

            visitedTiles = new Set();
            visitedTiles.add(`${startX},${startZ}`);

            while (scene.children.length > 1) {
                scene.remove(scene.children[1]);
            }

            // Ground and trees
            const groundShape = new THREE.Shape();
            groundShape.moveTo(-tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, -tileSize / 2);
            const groundColors = [0x4f2f1f, 0x2f4f2f, 0x4f4f1f];
            const canopyColors = [0x1f3f1f, 0x3f2f1f, 0x3f3f1f];
            const trunkColors = [0x2a1f15, 0x1f150f, 0x15100a];
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const isPath = maze[z][x] === 0;
                    const groundHeight = isPath ? 0.0 : minGroundHeight + Math.random() * (maxGroundHeight - minGroundHeight);
                    const extrudeSettings = { depth: groundHeight, bevelEnabled: false };
                    const groundGeometry = new THREE.ExtrudeGeometry(groundShape, extrudeSettings);
                    const groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: groundColors[Math.floor(Math.random() * groundColors.length)],
                        specular: 0x111111,
                        shininess: 5
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.set(x * tileSize + tileSize / 2, 0, z * tileSize + tileSize / 2);
                    scene.add(ground);


                    if (maze[z][x] === 1) { // Tree wall
                        const width = minTrunkWidth + Math.random() * (maxTrunkWidth - minTrunkWidth);
                        const height = minTrunkHeight + Math.random() * (maxTrunkHeight - minTrunkHeight);
                        const trunkColor = trunkColors[Math.floor(Math.random() * trunkColors.length)];
                        const treeMaterial = new THREE.MeshPhongMaterial({ 
                            color: trunkColor,
                            specular: 0x111111,
                            shininess: 5
                        });
                        const trunkPoints = [
                            new THREE.Vector2(0, 0),
                            new THREE.Vector2(width / 2, height * 0.3),
                            new THREE.Vector2(width / 2.5, height * 0.6),
                            new THREE.Vector2(width / 3, height * 0.9),
                            new THREE.Vector2(0, height)
                        ];
                        const treeGeometry = new THREE.LatheGeometry(trunkPoints, 12);
                        const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                        const treeX = x * tileSize + tileSize / 2;
                        const treeZ = z * tileSize + tileSize / 2;
                        tree.position.set(treeX, trunkOffsetY, treeZ);
                        scene.add(tree);

                        const canopySize = minCanopySize + Math.random() * (maxCanopySize - minCanopySize);
                        const canopyGeometry = new THREE.IcosahedronGeometry(canopySize / 2, 0);
                        const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
                        const canopyMaterial = new THREE.MeshPhongMaterial({ 
                            color: canopyColor,
                            specular: 0x111111,
                            shininess: 5,
                            side: THREE.DoubleSide
                        });
                        const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                        canopy.position.set(treeX, height + trunkOffsetY, treeZ);
                        scene.add(canopy);

                        trees.push({ x: treeX, z: treeZ, width: width });
                    }
                }
            }

            // Path tiles with colors, stones only on solution path
            mainPath.forEach(p => {
                const isDeadEnd = deadEnds.some(de => de.x === p.x && de.z === p.z);
                let color;
                if (isDeadEnd) {
                    const greyVal = 128 + Math.floor(Math.random() * (211 - 128)); // #808080 to #d3d3d3
                    color = (greyVal << 16) | (greyVal << 8) | greyVal;
                } else {
                    const greenR = 31 + Math.floor(Math.random() * 16); // 31-47 (#1f to #2f)
                    const greenG = 63 + Math.floor(Math.random() * 16); // 63-79 (#3f to #4f)
                    color = (greenR << 16) | (greenG << 8) | 31; // Dark green range
                    const stoneRadius = minPathStoneRadius + Math.random() * (maxPathStoneRadius - minPathStoneRadius);
                    const stoneGeometry = new THREE.CircleGeometry(stoneRadius, 32);
                    const stoneMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, shininess: 5 });
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.rotation.x = -Math.PI / 2;
                    stone.position.set(p.x * tileSize + tileSize / 2, 0.01, p.z * tileSize + tileSize / 2);
                    scene.add(stone); // Stones only on solution path
                }
            });

            // Coins and lights
            const coinGeometry = new THREE.TetrahedronGeometry(tileSize / 4, 0);
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffaa, specular: 0x111111, shininess: 5 });
            coins.forEach(coin => {
                const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
                coinMesh.position.set(coin.x + tileSize / 2, tileSize / 4, coin.z + tileSize / 2);
                coin.mesh = coinMesh;
                scene.add(coinMesh);
            });

            const lightSourceGeometry = new THREE.OctahedronGeometry(tileSize / 6, 0);
            const lightSourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa55, specular: 0x111111, shininess: 5, emissive: 0xffaa55, emissiveIntensity: 0 
            });
            lightSources.forEach(light => {
                const lightMesh = new THREE.Mesh(lightSourceGeometry, lightSourceMaterial);
                lightMesh.position.set(light.x + tileSize / 2, tileSize / 4, light.z + tileSize / 2);
                light.mesh = lightMesh;
                scene.add(lightMesh);
            });

            const goalGeometry = new THREE.DodecahedronGeometry(tileSize / 2, 0);
            const goalMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff, specular: 0x111111, shininess: 5 });
            const goalMesh = new THREE.Mesh(goalGeometry, goalMaterial);
            goalMesh.position.set(goal.x + tileSize / 2, tileSize / 2, goal.z + tileSize / 2);
            goal.mesh = goalMesh;
            scene.add(goalMesh);

            camera.position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            flashlightPower = 100;
            flashlight.intensity = maxFlashlightIntensity;
            flashlight.distance = maxFlashlightDistance;
            gameOver = false;

            // Initial minimap draw
            drawMinimap();

            console.log(`Maze generated - Size: ${mazeWidth}x${mazeHeight}, Dead ends: ${deadEnds.length}, Ground buffer: ${groundBuffer}`);
        }

        // Updated collision check
        function canMoveTo(newX, newZ) {
            const tileX = Math.floor(newX / tileSize);
            const tileZ = Math.floor(newZ / tileSize);
            if (tileX < 0 || tileX >= mazeWidth || tileZ < 0 || tileZ >= mazeHeight || maze[tileZ][tileX] === 1) {
                return false;
            }

            const playerRadius = playerSize / 2;
            const playerCenterX = newX + playerRadius;
            const playerCenterZ = newZ + playerRadius;

            for (const tree of trees) {
                const treeRadius = tree.width / 2;
                const dx = playerCenterX - tree.x;
                const dz = playerCenterZ - tree.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < (playerRadius + treeRadius)) {
                    return false;
                }
            }

            return true;
        }

        // Toggle minimap expansion from top-right
        function toggleMinimap() {
            if (isMinimapExpanded) {
                minimapCanvas.style.width = '200px';
                minimapCanvas.style.height = '200px';
                minimapCanvas.style.top = '10px';
                minimapCanvas.style.right = '10px';
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = 200;
                minimapCanvas.height = 200;
            } else {
                const padding = 50;
                const mapWidth = Math.min(window.innerWidth - 2 * padding, mazeWidth * 20);
                const mapHeight = Math.min(window.innerHeight - 2 * padding, mazeHeight * 20);
                minimapCanvas.style.width = `${mapWidth}px`;
                minimapCanvas.style.height = `${mapHeight}px`;
                minimapCanvas.style.top = `${10}px`;
                minimapCanvas.style.right = `${10}px`;
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = mapWidth;
                minimapCanvas.height = mapHeight;
            }
            isMinimapExpanded = !isMinimapExpanded;
            drawMinimap();
        }

        // Update game state
        function update() {
            if (gameOver) return;

            const velocity = new THREE.Vector3();
            if (moveForward || moveBackward || moveLeft || moveRight) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                if (moveForward) velocity.add(direction.clone().multiplyScalar(player.speed));
                if (moveBackward) velocity.sub(direction.clone().multiplyScalar(player.speed));
                const right = new THREE.Vector3();
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                if (moveLeft) velocity.sub(right.clone().multiplyScalar(player.speed));
                if (moveRight) velocity.add(right.clone().multiplyScalar(player.speed));
            }

            if (velocity.length() > 0) {
                const moveX = velocity.x;
                const moveZ = velocity.z;

                let newX = player.x + moveX;
                let newZ = player.z;
                if (canMoveTo(newX, newZ)) player.x = newX;

                newX = player.x;
                newZ = player.z + moveZ;
                if (canMoveTo(newX, newZ)) player.z = newZ;

                controls.getObject().position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);

                // Update visited tiles within 2-tile radius
                const tileX = Math.floor(player.x / tileSize);
                const tileZ = Math.floor(player.z / tileSize);
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = tileX + dx;
                        const nz = tileZ + dz;
                        if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                            visitedTiles.add(`${nx},${nz}`);
                        }
                    }
                }
            }

            coins.forEach(coin => {
                if (!coin.collected && Math.abs(player.x - coin.x) < tileSize && Math.abs(player.z - coin.z) < tileSize) {
                    coin.collected = true;
                    score += 10 * (levelsCompleted + 1);
                    scene.remove(coin.mesh);
                }
            });
            coins = coins.filter(coin => !coin.collected);

            lightSources.forEach(light => {
                if (!light.collected && Math.abs(player.x - light.x) < tileSize && Math.abs(player.z - light.z) < tileSize) {
                    light.collected = true;
                    scene.remove(light.mesh);
                    flashlightPower = Math.min(200, flashlightPower + 10);
                }
            });
            lightSources = lightSources.filter(light => !light.collected);

            if (flashlightPower > 0) {
                flashlightPower -= flashlightDrainRate / 60;
                flashlightPower = Math.max(0, flashlightPower);
                flashlight.intensity = maxFlashlightIntensity * Math.min(1, flashlightPower / 100);
                flashlight.distance = minFlashlightDistance + (maxFlashlightDistance - minFlashlightDistance) * Math.min(1, flashlightPower / 100);
                if (flashlightPower === 0) {
                    gameOver = true;
                    gameOverOverlay.style.display = 'block';
                    finalScoreSpan.textContent = score;
                    controls.unlock();
                }
            }

            const pulse = (Math.sin(Date.now() * 0.002) + 1) / 2;
            lightSources.forEach(light => {
                if (!light.collected && light.mesh) light.mesh.material.emissiveIntensity = pulse;
            });

            if (player.x !== player.lastX || player.z !== player.lastZ) {
                player.lastX = player.x;
                player.lastZ = player.z;
                drawMinimap();
            }

            if (Math.abs(player.x - goal.x) < tileSize && Math.abs(player.z - goal.z) < tileSize) {
                levelsCompleted++;
                score += 50 * levelsCompleted;
                alert(`Level ${levelsCompleted} Completed! Total Score: ${score}`);
                generateMaze();
            }
        }

        // Update HUD
        function updateHUD() {
            hud.level.textContent = levelsCompleted + 1;
            hud.score.textContent = score;
            hud.coins.textContent = deadEnds.length - coins.filter(c => !c.collected).length;
            hud.lightSources.textContent = lightSources.length - lightSources.filter(l => !l.collected).length;
            hud.flashlightMeter.textContent = `${Math.floor(flashlightPower)}%`;
        }

        // Draw minimap with 180-degree rotation
        function drawMinimap() {
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileZ = Math.floor(player.z / tileSize);
            const tileWidth = minimapCanvas.width / (isMinimapExpanded ? mazeWidth : 10);
            const tileHeight = minimapCanvas.height / (isMinimapExpanded ? mazeHeight : 10);

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            // Rotate 180 degrees around center
            minimapCtx.save();
            minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2);
            minimapCtx.rotate(Math.PI);
            minimapCtx.translate(-minimapCanvas.width / 2, -minimapCanvas.height / 2);

            if (isMinimapExpanded) {
                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                const isDeadEnd = deadEnds.some(de => de.x === x && de.z === z);
                                minimapCtx.fillStyle = isDeadEnd ? '#a0a0a0' : '#2f4f2f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    if (!coin.collected && visitedTiles.has(`${Math.floor(coin.x / tileSize)},${Math.floor(coin.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coin.x / tileSize) * tileWidth, (coin.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    if (!light.collected && visitedTiles.has(`${Math.floor(light.x / tileSize)},${Math.floor(light.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((light.x / tileSize) * tileWidth, (light.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                minimapCtx.fillStyle = 'blue';
                minimapCtx.fillRect(goal.x / tileSize * tileWidth, goal.z / tileSize * tileHeight, tileWidth, tileHeight);
            } else {
                const minX = Math.max(0, playerTileX - 5);
                const maxX = Math.min(mazeWidth - 1, playerTileX + 4);
                const minZ = Math.max(0, playerTileZ - 5);
                const maxZ = Math.min(mazeHeight - 1, playerTileZ + 4);

                for (let z = minZ; z <= maxZ; z++) {
                    for (let x = minX; x <= maxX; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                const isDeadEnd = deadEnds.some(de => de.x === x && de.z === z);
                                minimapCtx.fillStyle = isDeadEnd ? '#a0a0a0' : '#2f4f2f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    const coinX = Math.floor(coin.x / tileSize);
                    const coinZ = Math.floor(coin.z / tileSize);
                    if (!coin.collected && visitedTiles.has(`${coinX},${coinZ}`) && coinX >= minX && coinX <= maxX && coinZ >= minZ && coinZ <= maxZ) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coinX - playerTileX + 5) * tileWidth, (coinZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    const lightX = Math.floor(light.x / tileSize);
                    const lightZ = Math.floor(light.z / tileSize);
                    if (!light.collected && visitedTiles.has(`${lightX},${lightZ}`) && lightX >= minX && lightX <= maxX && lightZ >= minZ && lightZ <= maxZ) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((lightX - playerTileX + 5) * tileWidth, (lightZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                const goalTileX = Math.floor(goal.x / tileSize);
                const goalTileZ = Math.floor(goal.z / tileSize);
                if (goalTileX >= minX && goalTileX <= maxX && goalTileZ >= minZ && goalTileZ <= maxZ) {
                    minimapCtx.fillStyle = 'blue';
                    minimapCtx.fillRect((goalTileX - playerTileX + 5) * tileWidth, (goalTileZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                }
            }

            minimapCtx.fillStyle = 'red';
            const playerMapX = isMinimapExpanded ? (playerTileX * tileWidth) : (5 * tileWidth);
            const playerMapZ = isMinimapExpanded ? (playerTileZ * tileHeight) : (5 * tileHeight);
            minimapCtx.fillRect(playerMapX, playerMapZ, tileWidth, tileHeight);

            minimapCtx.restore();
        }

        // Reset game
        function resetGame() {
            gameOverOverlay.style.display = 'none';
            score = 0;
            levelsCompleted = 0;
            generateMaze();
            controls.lock();
        }

        // Game loop
        function gameLoop() {
            update();
            renderer.render(scene, camera);
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        generateMaze();
        gameLoop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isMinimapExpanded) toggleMinimap();
        });
    </script>
</body>
</html>