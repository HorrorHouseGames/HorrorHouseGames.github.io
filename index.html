<!DOCTYPE html>
<html>
<head>
    <title>Endless Maze Explorer 3D - Haunted Forest</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #gameCanvas { width: 100%; height: 100vh; }
        #minimap {
            border: 1px solid black;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            transition: all 0.5s ease;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #gameOverOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }
        #gameOverOverlay button, #swap-joysticks, #toggle-stones, #reveal-map {
            padding: 5px 10px;
            font-size: 12px;
            margin-top: 5px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #gameOverOverlay button:hover, #swap-joysticks:hover, #toggle-stones:hover, #reveal-map:hover { background-color: #cc3333; }
        #joystick-move, #joystick-camera {
            position: absolute;
            bottom: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
            display: none;
        }
        #joystick-move { left: 20px; }
        #joystick-camera { right: 20px; }
        #joystick-move-knob, #joystick-camera-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <canvas id="minimap"></canvas>
    <div id="gameCanvas"></div>
    <div id="hud">
        Level: <span id="level">1</span><br>
        Score: <span id="score">0</span><br>
        Health: <span id="health">100</span><br>
        Coins: <span id="coins">0/0 found</span><br>
        Light Sources: <span id="lightSources">0/0 found</span><br>
        Flashlight: <span id="flashlightMeter">100%</span><br>
        <div id="controls-info"></div>
        <button id="swap-joysticks" style="display: none;">Swap Joysticks</button>
        <button id="toggle-stones">Show Path Stones</button>
        <button id="reveal-map">Reveal Map</button>
    </div>
    <div id="gameOverOverlay">
        <h2>Game Over</h2>
        <p id="gameOverMessage">Your flashlight ran out of power!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">Restart</button>
    </div>
    <div id="joystick-move">
        <div id="joystick-move-knob"></div>
    </div>
    <div id="joystick-camera">
        <div id="joystick-camera-knob"></div>
    </div>

    <script>
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;
        const hud = {
            level: document.getElementById('level'),
            score: document.getElementById('score'),
            health: document.getElementById('health'),
            coins: document.getElementById('coins'),
            lightSources: document.getElementById('lightSources'),
            flashlightMeter: document.getElementById('flashlightMeter'),
            controlsInfo: document.getElementById('controls-info'),
            swapJoysticks: document.getElementById('swap-joysticks'),
            toggleStones: document.getElementById('toggle-stones'),
            revealMap: document.getElementById('reveal-map')
        };
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreSpan = document.getElementById('finalScore');
        const joystickMove = document.getElementById('joystick-move');
        const joystickMoveKnob = document.getElementById('joystick-move-knob');
        const joystickCamera = document.getElementById('joystick-camera');
        const joystickCameraKnob = document.getElementById('joystick-camera-knob');

        let isJoystickSwapped = false;
        if (navigator.maxTouchPoints > 0) {
            joystickMove.style.display = 'block';
            joystickCamera.style.display = 'block';
            hud.swapJoysticks.style.display = 'block';
            hud.swapJoysticks.addEventListener('click', () => {
                isJoystickSwapped = !isJoystickSwapped;
                joystickMove.style.left = isJoystickSwapped ? 'auto' : '20px';
                joystickMove.style.right = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.left = isJoystickSwapped ? '20px' : 'auto';
                joystickCamera.style.right = isJoystickSwapped ? 'auto' : '20px';
            });
        }

        const tileSize = 1;
        const playerSize = 0.3;
        const baseMazeSize = 15;
        const sizeIncrease = 6;
        const maxMazeSize = 100;
        let mazeWidth = baseMazeSize;
        let mazeHeight = baseMazeSize;
        let player = { x: tileSize, z: tileSize, speed: 0.05, lastX: tileSize, lastZ: tileSize, health: 100 };
        let goal = { x: 0, z: 0 };
        let maze = [];
        let trees = [];
        let coins = [];
        let lightSources = [];
        let ghosts = [];
        let score = 0;
        let levelsCompleted = 0;
        let mainPath = [];
        let deadEnds = [];
        let optimalPath = [];
        let flashlightPower = 100;
        const maxFlashlightIntensity = 2.5;
        const minFlashlightDistance = 1;
        const maxFlashlightDistance = 10;
        const flashlightDrainRate = 1;
        let gameOver = false;
        let visitedTiles = new Set();
        let isMinimapExpanded = false;
        let stonesVisible = false;
        let stoneMeshes = [];
        let lastBeamTime = 0;
        const beamCooldown = 1000; // 1 second in ms
        const ghostAttackRange = 5 * tileSize; // 5 tiles

        const minGroundHeight = 0.0;
        const maxGroundHeight = 0.1;
        const minCanopySize = 0.9;
        const maxCanopySize = 1.2;
        const minTrunkWidth = 0.2;
        const maxTrunkWidth = 0.4;
        const minTrunkHeight = 1.2;
        const maxTrunkHeight = 2.2;
        const minPathStoneRadius = tileSize / 20;
        const maxPathStoneRadius = tileSize / 2;
        const pathWidth = 1;
        const trunkOffsetY = -0.7;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('gameCanvas').appendChild(renderer.domElement);

        scene.fog = new THREE.Fog(0x000000, 8, 12);

        const flashlight = new THREE.SpotLight(0xaaaaaa, maxFlashlightIntensity, maxFlashlightDistance, Math.PI / 3, 0.9);
        flashlight.position.set(0, 0.5, 0);
        flashlight.target = new THREE.Object3D();
        flashlight.target.position.set(0, 0, -1);
        camera.add(flashlight);
        camera.add(flashlight.target);
        scene.add(camera);

        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => controls.lock());

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, shootBeam = false;
        document.addEventListener('keydown', (e) => {
            if (!gameOver) {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'KeyE': shootBeam = true; break;
                    case 'Space': if (!isMinimapExpanded) toggleMinimap(); break;
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
                case 'KeyE': shootBeam = false; break;
                case 'Space': if (isMinimapExpanded) toggleMinimap(); break;
            }
        });

        let moveJoystickActive = false, cameraJoystickActive = false;
        let moveJoystickDeltaX = 0, moveJoystickDeltaY = 0;
        let cameraJoystickDeltaX = 0, cameraJoystickDeltaY = 0;
        const joystickRadius = 50;

        function setupJoystick(joystickElement, knobElement, isMoveDefault) {
            const isMove = isJoystickSwapped ? !isMoveDefault : isMoveDefault;
            joystickElement.addEventListener('touchstart', (e) => {
                if (!gameOver && e.touches.length <= 2) {
                    const touch = e.touches[0];
                    const rect = joystickElement.getBoundingClientRect();
                    const centerX = rect.left + joystickRadius;
                    const centerY = rect.top + joystickRadius;
                    if (isMove) {
                        moveJoystickActive = true;
                        moveJoystickDeltaX = touch.clientX - centerX;
                        moveJoystickDeltaY = touch.clientY - centerY;
                    } else {
                        cameraJoystickActive = true;
                        cameraJoystickDeltaX = touch.clientX - centerX;
                        cameraJoystickDeltaY = touch.clientY - centerY;
                        shootBeam = true; // Tap camera joystick to shoot
                    }
                    updateJoystickPosition(knobElement, touch.clientX, touch.clientY, rect);
                    e.preventDefault();
                }
            });

            joystickElement.addEventListener('touchmove', (e) => {
                if (!gameOver && e.touches.length <= 2) {
                    const touch = e.touches[isMove && moveJoystickActive ? 0 : 1] || e.touches[0];
                    const rect = joystickElement.getBoundingClientRect();
                    const centerX = rect.left + joystickRadius;
                    const centerY = rect.top + joystickRadius;
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > joystickRadius) {
                        dx = dx * joystickRadius / distance;
                        dy = dy * joystickRadius / distance;
                    }
                    if (isMove) {
                        moveJoystickDeltaX = dx;
                        moveJoystickDeltaY = dy;
                    } else {
                        cameraJoystickDeltaX = dx;
                        cameraJoystickDeltaY = dy;
                    }
                    updateJoystickPosition(knobElement, centerX + dx, centerY + dy, rect);
                    e.preventDefault();
                }
            });

            joystickElement.addEventListener('touchend', (e) => {
                if (!gameOver) {
                    if (isMove) {
                        moveJoystickActive = false;
                        moveJoystickDeltaX = 0;
                        moveJoystickDeltaY = 0;
                    } else {
                        cameraJoystickActive = false;
                        cameraJoystickDeltaX = 0;
                        cameraJoystickDeltaY = 0;
                        shootBeam = false;
                    }
                    knobElement.style.left = '50%';
                    knobElement.style.top = '50%';
                    e.preventDefault();
                }
            });
        }

        function updateJoystickPosition(knob, x, y, rect) {
            const knobX = x - rect.left - 20;
            const knobY = y - rect.top - 20;
            knob.style.left = `${knobX}px`;
            knob.style.top = `${knobY}px`;
        }

        setupJoystick(joystickMove, joystickMoveKnob, true);
        setupJoystick(joystickCamera, joystickCameraKnob, false);

        function generateMaze() {
            mazeWidth = Math.min(baseMazeSize + sizeIncrease * levelsCompleted, maxMazeSize);
            mazeHeight = mazeWidth;

            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1);
                }
                maze.push(row);
            }

            let startX = Math.floor(mazeWidth / 2);
            let startZ = Math.floor(mazeHeight / 2);
            let goalX = mazeWidth - 4;
            let goalZ = mazeHeight - 4;

            const stack = [{ x: startX, z: startZ }];
            maze[startZ][startX] = 0;
            const basePathTiles = Math.floor((mazeWidth * mazeHeight) / 8);
            const maxPathTiles = basePathTiles + levelsCompleted * 20;
            let pathTiles = 1;

            function carvePath(x, z) {
                if (pathTiles >= maxPathTiles) return;

                const directions = [
                    { dx: 4, dz: 0 }, { dx: -4, dz: 0 },
                    { dx: 0, dz: 4 }, { dx: 0, dz: -4 }
                ].sort(() => Math.random() - 0.5);

                for (const dir of directions) {
                    const newX = x + dir.dx;
                    const newZ = z + dir.dz;

                    if (newX >= 2 && newX < mazeWidth - 2 && newZ >= 2 && newZ < mazeHeight - 2 &&
                        maze[newZ][newX] === 1 && pathTiles < maxPathTiles) {
                        const stepX = dir.dx === 0 ? 0 : dir.dx > 0 ? 1 : -1;
                        const stepZ = dir.dz === 0 ? 0 : dir.dz > 0 ? 1 : -1;
                        let currentX = x;
                        let currentZ = z;
                        while (currentX !== newX || currentZ !== newZ) {
                            currentX += stepX;
                            currentZ += stepZ;
                            if (maze[currentZ][currentX] === 1) {
                                maze[currentZ][currentX] = 0;
                                pathTiles++;
                            }
                        }
                        stack.push({ x: newX, z: newZ });
                        carvePath(newX, newZ);
                    }
                }
            }

            carvePath(startX, startZ);

            function ensureGoalReachable() {
                let closestPathX = startX;
                let closestPathZ = startZ;
                let minDist = Infinity;

                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (maze[z][x] === 0) {
                            const dist = Math.abs(x - goalX) + Math.abs(z - goalZ);
                            if (dist < minDist) {
                                minDist = dist;
                                closestPathX = x;
                                closestPathZ = z;
                            }
                        }
                    }
                }

                let currentX = goalX;
                let currentZ = goalZ;
                while (currentX !== closestPathX || currentZ !== closestPathZ) {
                    if (currentX < closestPathX) currentX++;
                    else if (currentX > closestPathX) currentX--;
                    else if (currentZ < closestPathZ) currentZ++;
                    else if (currentZ > closestPathZ) currentZ--;
                    if (maze[currentZ][currentX] === 1) maze[currentZ][currentX] = 0;
                }

                goalX = currentX;
                goalZ = currentZ;
            }

            ensureGoalReachable();

            const tempMaze = maze.map(row => [...row]);
            maze = [];
            for (let z = 0; z < mazeHeight; z++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(1);
                }
                maze.push(row);
            }

            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (tempMaze[z][x] === 0) {
                        maze[z][x] = 0;
                        if (x > 0 && tempMaze[z][x-1] !== 0) maze[z][x-1] = 2;
                        if (x < mazeWidth - 1 && tempMaze[z][x+1] !== 0) maze[z][x+1] = 2;
                        if (z > 0 && tempMaze[z-1][x] !== 0) maze[z-1][x] = 2;
                        if (z < mazeHeight - 1 && tempMaze[z+1][x] !== 0) maze[z+1][x] = 2;
                    }
                }
            }

            function findOptimalPath() {
                const queue = [{ x: startX, z: startZ, path: [{ x: startX, z: startZ }] }];
                const visited = new Set([`${startX},${startZ}`]);
                const directions = [
                    { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
                    { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
                ];

                while (queue.length > 0) {
                    const { x, z, path } = queue.shift();
                    if (x === goalX && z === goalZ) return path;

                    for (const dir of directions) {
                        const newX = x + dir.dx;
                        const newZ = z + dir.dz;
                        const key = `${newX},${newZ}`;
                        if (newX >= 0 && newX < mazeWidth && newZ >= 0 && newZ < mazeHeight &&
                            maze[newZ][newX] === 0 && !visited.has(key)) {
                            visited.add(key);
                            queue.push({ x: newX, z: newZ, path: [...path, { x: newX, z: newZ }] });
                        }
                    }
                }
                console.error("No optimal path found!");
                return [];
            }

            mainPath = [];
            deadEnds = [];
            const pathSet = new Set();
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[z][x] === 0) {
                        mainPath.push({ x, z });
                        pathSet.add(`${x},${z}`);
                    }
                }
            }

            const targetDeadEnds = 3 + Math.floor(levelsCompleted / 2);
            for (let i = 0; i < targetDeadEnds; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const startIdx = Math.floor(Math.random() * mainPath.length);
                    const { x, z } = mainPath[startIdx];
                    const directions = [
                        { dx: 4, dz: 0 }, { dx: -4, dz: 0 },
                        { dx: 0, dz: 4 }, { dx: 0, dz: -4 }
                    ];
                    const dir = directions[Math.floor(Math.random() * 4)];
                    const endX = x + dir.dx;
                    const endZ = z + dir.dz;
                    if (endX >= 2 && endX < mazeWidth - 2 && endZ >= 2 && endZ < mazeHeight - 2 &&
                        maze[endZ][endX] === 1 && !pathSet.has(`${endX},${endZ}`)) {
                        const stepX = dir.dx === 0 ? 0 : dir.dx > 0 ? 1 : -1;
                        const stepZ = dir.dz === 0 ? 0 : dir.dz > 0 ? 1 : -1;
                        let currentX = x;
                        let currentZ = z;
                        while (currentX !== endX || currentZ !== endZ) {
                            currentX += stepX;
                            currentZ += stepZ;
                            maze[currentZ][currentX] = 0;
                            if (currentX > 0) maze[currentZ][currentX-1] = 2;
                            if (currentX < mazeWidth - 1) maze[currentZ][currentX+1] = 2;
                            if (currentZ > 0) maze[currentZ-1][currentX] = 2;
                            if (currentZ < mazeHeight - 1) maze[currentZ+1][currentX] = 2;
                        }
                        deadEnds.push({ x: endX, z: endZ });
                        mainPath.push({ x: endX, z: endZ });
                        pathSet.add(`${endX},${endZ}`);
                        break;
                    }
                    attempts++;
                }
            }

            optimalPath = findOptimalPath();
            if (optimalPath.length === 0) {
                console.error("Failed to generate solvable maze, retrying...");
                return generateMaze();
            }

            player.x = startX * tileSize;
            player.z = startZ * tileSize;
            player.lastX = player.x;
            player.lastZ = player.z;
            player.health = 100;
            goal.x = goalX * tileSize;
            goal.z = goalZ * tileSize;

            coins = [];
            for (let z = 1; z < mazeHeight - 1; z++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    if (maze[z][x] === 0) {
                        let groundCount = 0;
                        if (maze[z][x-1] === 2) groundCount++;
                        if (maze[z][x+1] === 2) groundCount++;
                        if (maze[z-1][x] === 2) groundCount++;
                        if (maze[z+1][x] === 2) groundCount++;
                        if (groundCount === 3) {
                            coins.push({ x: x * tileSize, z: z * tileSize, collected: false });
                        }
                    }
                }
            }

            lightSources = [];
            for (let i = 0; i < optimalPath.length; i += 5) {
                const p = optimalPath[i];
                lightSources.push({ x: p.x * tileSize, z: p.z * tileSize, collected: false });
            }

            ghosts = [];
            coins.forEach(coin => {
                const coinX = Math.floor(coin.x / tileSize);
                const coinZ = Math.floor(coin.z / tileSize);
                const spawnOptions = [];
                for (let dz = -1; dz <= 1; dz++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const newX = coinX + dx;
                        const newZ = coinZ + dz;
                        if (newX >= 0 && newX < mazeWidth && newZ >= 0 && newZ < mazeHeight &&
                            (maze[newZ][newX] === 0 || maze[newZ][newX] === 2)) {
                            spawnOptions.push({ x: newX * tileSize, z: newZ * tileSize });
                        }
                    }
                }
                if (spawnOptions.length > 0 && Math.random() < 0.5) { // 50% chance per coin
                    const spawn = spawnOptions[Math.floor(Math.random() * spawnOptions.length)];
                    const ghostGeometry = new THREE.SphereGeometry(tileSize / 3, 16, 16);
                    const ghostMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xaaaaaa, 
                        transparent: true, 
                        opacity: 0.7, 
                        specular: 0x111111, 
                        shininess: 5 
                    });
                    const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
                    ghost.position.set(spawn.x + tileSize / 2, tileSize / 2, spawn.z + tileSize / 2);
                    scene.add(ghost); // Ensure ghost is added to scene
                    ghosts.push({ 
                        mesh: ghost, 
                        spawnX: spawn.x, // Store initial spawn position
                        spawnZ: spawn.z,
                        x: spawn.x, 
                        z: spawn.z, 
                        health: 50, 
                        speed: 0.03, 
                        lastAttack: 0, 
                        attackCooldown: 2000 // 2 seconds
                    });
                }
            });

            trees = [];
            visitedTiles = new Set();
            visitedTiles.add(`${startX},${startZ}`);
            stoneMeshes = [];

            while (scene.children.length > 1) {
                scene.remove(scene.children[1]);
            }

            const groundShape = new THREE.Shape();
            groundShape.moveTo(-tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, -tileSize / 2);
            groundShape.lineTo(tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, tileSize / 2);
            groundShape.lineTo(-tileSize / 2, -tileSize / 2);
            const groundColors = [0x4f2f1f, 0x2f4f2f, 0x4f4f1f];
            const canopyColors = [0x1f3f1f, 0x3f2f1f, 0x3f3f1f];
            const trunkColors = [0x2a1f15, 0x1f150f, 0x15100a];
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const isPath = maze[z][x] === 0;
                    const groundHeight = isPath ? 0.0 : minGroundHeight + Math.random() * (maxGroundHeight - minGroundHeight);
                    const extrudeSettings = { depth: groundHeight, bevelEnabled: false };
                    const groundGeometry = new THREE.ExtrudeGeometry(groundShape, extrudeSettings);
                    const groundMaterial = new THREE.MeshPhongMaterial({ 
                        color: isPath ? 0x3f2f1f : groundColors[Math.floor(Math.random() * groundColors.length)],
                        specular: 0x111111,
                        shininess: 5
                    });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.set(x * tileSize + tileSize / 2, 0, z * tileSize + tileSize / 2);
                    scene.add(ground);

                    if (maze[z][x] === 1) {
                        const width = minTrunkWidth + Math.random() * (maxTrunkWidth - minTrunkWidth);
                        const height = minTrunkHeight + Math.random() * (maxTrunkHeight - minTrunkHeight);
                        const trunkColor = trunkColors[Math.floor(Math.random() * trunkColors.length)];
                        const treeMaterial = new THREE.MeshPhongMaterial({ 
                            color: trunkColor,
                            specular: 0x111111,
                            shininess: 5
                        });
                        const trunkPoints = [
                            new THREE.Vector2(0, 0),
                            new THREE.Vector2(width / 2, height * 0.3),
                            new THREE.Vector2(width / 2.5, height * 0.6),
                            new THREE.Vector2(width / 3, height * 0.9),
                            new THREE.Vector2(0, height)
                        ];
                        const treeGeometry = new THREE.LatheGeometry(trunkPoints, 12);
                        const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                        const treeX = x * tileSize + tileSize / 2;
                        const treeZ = z * tileSize + tileSize / 2;
                        tree.position.set(treeX, trunkOffsetY, treeZ);
                        scene.add(tree);

                        const canopySize = minCanopySize + Math.random() * (maxCanopySize - minCanopySize);
                        const canopyGeometry = new THREE.IcosahedronGeometry(canopySize / 2, 0);
                        const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
                        const canopyMaterial = new THREE.MeshPhongMaterial({ 
                            color: canopyColor,
                            specular: 0x111111,
                            shininess: 5,
                            side: THREE.DoubleSide
                        });
                        const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                        canopy.position.set(treeX, height + trunkOffsetY, treeZ);
                        scene.add(canopy);

                        trees.push({ x: treeX, z: treeZ, width: width });
                    }
                }
            }

            mainPath.forEach(p => {
                const isOptimal = optimalPath.some(op => op.x === p.x && op.z === p.z);
                if (isOptimal) {
                    const greenR = 31 + Math.floor(Math.random() * 16);
                    const greenG = 63 + Math.floor(Math.random() * 16);
                    const color = (greenR << 16) | (greenG << 8) | 31;
                    const stoneRadius = minPathStoneRadius + Math.random() * (maxPathStoneRadius - minPathStoneRadius);
                    const stoneGeometry = new THREE.CircleGeometry(stoneRadius, 32);
                    const stoneMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, shininess: 5 });
                    const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
                    stone.rotation.x = -Math.PI / 2;
                    stone.position.set(p.x * tileSize + tileSize / 2, 0.01, p.z * tileSize + tileSize / 2);
                    stone.visible = false; // Hidden by default
                    stoneMeshes.push(stone);
                    scene.add(stone);
                }
            });

            const coinGeometry = new THREE.TetrahedronGeometry(tileSize / 4, 0);
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffaa, specular: 0x111111, shininess: 5 });
            coins.forEach(coin => {
                const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
                coinMesh.position.set(coin.x + tileSize / 2, tileSize / 4, coin.z + tileSize / 2);
                coin.mesh = coinMesh;
                scene.add(coinMesh);
            });

            const lightSourceGeometry = new THREE.OctahedronGeometry(tileSize / 6, 0);
            const lightSourceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa55, specular: 0x111111, shininess: 5, emissive: 0xffaa55, emissiveIntensity: 0 
            });
            lightSources.forEach(light => {
                const lightMesh = new THREE.Mesh(lightSourceGeometry, lightSourceMaterial);
                lightMesh.position.set(light.x + tileSize / 2, tileSize / 4, light.z + tileSize / 2);
                light.mesh = lightMesh;
                scene.add(lightMesh);
            });

            const goalGeometry = new THREE.DodecahedronGeometry(tileSize / 2, 0);
            const goalMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff, specular: 0x111111, shininess: 5 });
            const goalMesh = new THREE.Mesh(goalGeometry, goalMaterial);
            goalMesh.position.set(goal.x + tileSize / 2, tileSize / 2, goal.z + tileSize / 2);
            goal.mesh = goalMesh;
            scene.add(goalMesh);

            // Re-add ghosts to ensure theyâ€™re in the scene
            ghosts.forEach(ghost => {
                scene.add(ghost.mesh);
            });

            camera.position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            camera.rotation.set(0, 0, 0);

            if (optimalPath.length > 1) {
                const nextTile = optimalPath[1];
                const dx = (nextTile.x * tileSize + tileSize / 2) - camera.position.x;
                const dz = (nextTile.z * tileSize + tileSize / 2) - camera.position.z;
                const yaw = Math.atan2(dx, dz);
                controls.getObject().rotation.y = yaw;
            }

            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            shootBeam = false;
            flashlightPower = 100;
            flashlight.intensity = maxFlashlightIntensity;
            flashlight.distance = maxFlashlightDistance;
            gameOver = false;
            stonesVisible = false;
            hud.toggleStones.textContent = "Show Path Stones";

            drawMinimap();
            updateHUD();

            console.log(`Maze generated - Size: ${mazeWidth}x${mazeHeight}, Optimal path: ${optimalPath.length}, Coins: ${coins.length}, Lights: ${lightSources.length}, Ghosts: ${ghosts.length}`);
        }

        function canMoveTo(newX, newZ) {
            const tileX = Math.floor(newX / tileSize);
            const tileZ = Math.floor(newZ / tileSize);
            if (tileX < 0 || tileX >= mazeWidth || tileZ < 0 || tileZ >= mazeHeight || maze[tileZ][tileX] === 1) {
                return false;
            }

            const playerRadius = playerSize / 2;
            const playerCenterX = newX + playerRadius;
            const playerCenterZ = newZ + playerRadius;

            for (const tree of trees) {
                const treeRadius = tree.width / 2;
                const dx = playerCenterX - tree.x;
                const dz = playerCenterZ - tree.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < (playerRadius + treeRadius)) {
                    return false;
                }
            }

            return true;
        }

        function shootLightBeam() {
            const currentTime = Date.now();
            if (currentTime - lastBeamTime < beamCooldown || flashlightPower < 5 || gameOver) return;

            lastBeamTime = currentTime;
            flashlightPower -= 5;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const start = new THREE.Vector3(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            const end = start.clone().add(direction.multiplyScalar(5 * tileSize));

            const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, start.distanceTo(end), 8);
            const beamMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.lerpVectors(start, end, 0.5);
            beam.lookAt(end);
            beam.rotateX(Math.PI / 2);
            scene.add(beam);

            setTimeout(() => scene.remove(beam), 100); // Beam visible for 0.1s

            ghosts.forEach(ghost => {
                const ghostPos = new THREE.Vector3(ghost.x + tileSize / 2, tileSize / 2, ghost.z + tileSize / 2);
                const distToBeam = ghostPos.distanceTo(start) + ghostPos.distanceTo(end) - start.distanceTo(end);
                if (distToBeam < 0.5 && ghostPos.distanceTo(start) < 5 * tileSize) { // Within beam range and width
                    ghost.health -= 25;
                    if (ghost.health <= 0) {
                        scene.remove(ghost.mesh);
                        ghosts = ghosts.filter(g => g !== ghost);
                    }
                }
            });
        }

        function updateGhosts() {
            const currentTime = Date.now();
            ghosts.forEach(ghost => {
                const dx = player.x - ghost.spawnX; // Use spawnX for distance check
                const dz = player.z - ghost.spawnZ; // Use spawnZ for distance check
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < ghostAttackRange) { // Only move if player is within range
                    const moveDx = player.x - ghost.x;
                    const moveDz = player.z - ghost.z;
                    const moveDistance = Math.sqrt(moveDx * moveDx + moveDz * moveDz);
                    if (moveDistance > 0) {
                        const directionX = moveDx / moveDistance;
                        const directionZ = moveDz / moveDistance;
                        ghost.x += directionX * ghost.speed;
                        ghost.z += directionZ * ghost.speed;
                    }

                    if (moveDistance < playerSize && currentTime - ghost.lastAttack > ghost.attackCooldown) {
                        player.health -= 10;
                        ghost.lastAttack = currentTime;
                        if (player.health <= 0) {
                            gameOver = true;
                            gameOverMessage.textContent = "You were overwhelmed by ghosts!";
                            gameOverOverlay.style.display = 'block';
                            finalScoreSpan.textContent = score;
                            controls.unlock();
                        }
                    }
                }

                // Update ghost position with slight bobbing
                ghost.mesh.position.set(ghost.x + tileSize / 2, tileSize / 2 + Math.sin(currentTime * 0.002) * 0.2, ghost.z + tileSize / 2);
            });
        }

        function toggleMinimap() {
            if (isMinimapExpanded) {
                minimapCanvas.style.width = '200px';
                minimapCanvas.style.height = '200px';
                minimapCanvas.style.top = '10px';
                minimapCanvas.style.right = '10px';
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = 200;
                minimapCanvas.height = 200;
            } else {
                const padding = 50;
                const mapWidth = Math.min(window.innerWidth - 2 * padding, mazeWidth * 20);
                const mapHeight = Math.min(window.innerHeight - 2 * padding, mazeHeight * 20);
                minimapCanvas.style.width = `${mapWidth}px`;
                minimapCanvas.style.height = `${mapHeight}px`;
                minimapCanvas.style.top = `${10}px`;
                minimapCanvas.style.right = `${10}px`;
                minimapCanvas.style.left = 'auto';
                minimapCanvas.width = mapWidth;
                minimapCanvas.height = mapHeight;
            }
            isMinimapExpanded = !isMinimapExpanded;
            drawMinimap();
        }

        function toggleStones() {
            stonesVisible = !stonesVisible;
            stoneMeshes.forEach(stone => stone.visible = stonesVisible);
            hud.toggleStones.textContent = stonesVisible ? "Hide Path Stones" : "Show Path Stones";
        }

        function revealMap() {
            for (let z = 0; z < mazeHeight; z++) {
                for (let x = 0; x < mazeWidth; x++) {
                    visitedTiles.add(`${x},${z}`);
                }
            }
            drawMinimap();
        }

        hud.toggleStones.addEventListener('click', toggleStones);
        hud.revealMap.addEventListener('click', revealMap);

        function update() {
            if (gameOver) return;

            const velocity = new THREE.Vector3();
            if (moveForward || moveBackward || moveLeft || moveRight || moveJoystickActive) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                if (moveForward) velocity.add(direction.clone().multiplyScalar(player.speed));
                if (moveBackward) velocity.sub(direction.clone().multiplyScalar(player.speed));
                const right = new THREE.Vector3();
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                if (moveLeft) velocity.sub(right.clone().multiplyScalar(player.speed));
                if (moveRight) velocity.add(right.clone().multiplyScalar(player.speed));

                if (moveJoystickActive) {
                    const joystickMagnitude = Math.sqrt(moveJoystickDeltaX * moveJoystickDeltaX + moveJoystickDeltaY * moveJoystickDeltaY);
                    if (joystickMagnitude > 0) {
                        const joystickDirX = moveJoystickDeltaX / joystickMagnitude;
                        const joystickDirY = moveJoystickDeltaY / joystickMagnitude;
                        const forwardComponent = direction.clone().multiplyScalar(-joystickDirY);
                        const rightComponent = right.clone().multiplyScalar(joystickDirX);
                        velocity.add(forwardComponent).add(rightComponent).normalize().multiplyScalar(player.speed * (joystickMagnitude / joystickRadius));
                    }
                }
            }

            if (cameraJoystickActive) {
                const rotateSpeed = 0.005;
                controls.getObject().rotation.y -= cameraJoystickDeltaX * rotateSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - cameraJoystickDeltaY * rotateSpeed));
            }

            if (velocity.length() > 0) {
                const moveX = velocity.x;
                const moveZ = velocity.z;

                let newX = player.x + moveX;
                let newZ = player.z;
                if (canMoveTo(newX, newZ)) player.x = newX;

                newX = player.x;
                newZ = player.z + moveZ;
                if (canMoveTo(newX, newZ)) player.z = newZ;

                controls.getObject().position.set(player.x + playerSize / 2, tileSize / 2, player.z + playerSize / 2);
            }

            if (shootBeam) shootLightBeam();

            updateGhosts();

            coins.forEach(coin => {
                if (!coin.collected && Math.abs(player.x - coin.x) < tileSize && Math.abs(player.z - coin.z) < tileSize) {
                    coin.collected = true;
                    score += 10 * (levelsCompleted + 1);
                    scene.remove(coin.mesh);
                }
            });
            coins = coins.filter(coin => !coin.collected);

            lightSources.forEach(light => {
                if (!light.collected && Math.abs(player.x - light.x) < tileSize && Math.abs(player.z - light.z) < tileSize) {
                    light.collected = true;
                    scene.remove(light.mesh);
                    flashlightPower = Math.min(200, flashlightPower + 10);
                }
            });
            lightSources = lightSources.filter(light => !light.collected);

            if (flashlightPower > 0) {
                flashlightPower -= flashlightDrainRate / 60;
                flashlightPower = Math.max(0, flashlightPower);
                flashlight.intensity = maxFlashlightIntensity * Math.min(1, flashlightPower / 100);
                flashlight.distance = minFlashlightDistance + (maxFlashlightDistance - minFlashlightDistance) * Math.min(1, flashlightPower / 100);
                if (flashlightPower === 0) {
                    gameOver = true;
                    gameOverMessage.textContent = "Your flashlight ran out of power!";
                    gameOverOverlay.style.display = 'block';
                    finalScoreSpan.textContent = score;
                    controls.unlock();
                }
            }

            const pulse = (Math.sin(Date.now() * 0.002) + 1) / 2;
            lightSources.forEach(light => {
                if (!light.collected && light.mesh) light.mesh.material.emissiveIntensity = pulse;
            });

            if (player.x !== player.lastX || player.z !== player.lastZ) {
                player.lastX = player.x;
                player.lastZ = player.z;
                drawMinimap();

                const tileX = Math.floor(player.x / tileSize);
                const tileZ = Math.floor(player.z / tileSize);
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = tileX + dx;
                        const nz = tileZ + dz;
                        if (nx >= 0 && nx < mazeWidth && nz >= 0 && nz < mazeHeight) {
                            visitedTiles.add(`${nx},${nz}`);
                        }
                    }
                }
            }

            if (Math.abs(player.x - goal.x) < tileSize && Math.abs(player.z - goal.z) < tileSize) {
                levelsCompleted++;
                score += 50 * levelsCompleted;
                alert(`Level ${levelsCompleted} Completed! Total Score: ${score}`);
                generateMaze();
            }
        }

        function updateHUD() {
            hud.level.textContent = levelsCompleted + 1;
            hud.score.textContent = score;
            hud.health.textContent = Math.max(0, Math.floor(player.health));
            const totalCoins = coins.length + coins.filter(c => c.collected).length;
            const foundCoins = coins.filter(c => c.collected).length;
            hud.coins.textContent = `${foundCoins}/${totalCoins} found`;
            const totalLights = lightSources.length + lightSources.filter(l => l.collected).length;
            const foundLights = lightSources.filter(l => l.collected).length;
            hud.lightSources.textContent = `${foundLights}/${totalLights} found`;
            hud.flashlightMeter.textContent = `${Math.floor(flashlightPower)}%`;
            hud.controlsInfo.innerHTML = navigator.maxTouchPoints > 0 ?
                `<br>Controls:<br>${isJoystickSwapped ? 'Right' : 'Left'} Joystick: Move<br>${isJoystickSwapped ? 'Left' : 'Right'} Joystick: Look/Shoot<br>Spacebar: Toggle Map` :
                '<br>Controls:<br>WASD/Arrows: Move<br>Mouse: Look<br>E: Shoot<br>Spacebar: Toggle Map';
        }

        function drawMinimap() {
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileZ = Math.floor(player.z / tileSize);
            const tileWidth = minimapCanvas.width / (isMinimapExpanded ? mazeWidth : 10);
            const tileHeight = minimapCanvas.height / (isMinimapExpanded ? mazeHeight : 10);

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            minimapCtx.save();
            minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2);
            minimapCtx.rotate(Math.PI);
            minimapCtx.translate(-minimapCanvas.width / 2, -minimapCanvas.height / 2);

            if (isMinimapExpanded) {
                for (let z = 0; z < mazeHeight; z++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                minimapCtx.fillStyle = '#3f2f1f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect(x * tileWidth, z * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    if (!coin.collected && visitedTiles.has(`${Math.floor(coin.x / tileSize)},${Math.floor(coin.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coin.x / tileSize) * tileWidth, (coin.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    if (!light.collected && visitedTiles.has(`${Math.floor(light.x / tileSize)},${Math.floor(light.z / tileSize)}`)) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((light.x / tileSize) * tileWidth, (light.z / tileSize) * tileHeight, tileWidth, tileHeight);
                    }
                });

                ghosts.forEach(ghost => {
                    const ghostX = Math.floor(ghost.x / tileSize);
                    const ghostZ = Math.floor(ghost.z / tileSize);
                    if (visitedTiles.has(`${ghostX},${ghostZ}`)) {
                        minimapCtx.fillStyle = 'white';
                        minimapCtx.fillRect(ghostX * tileWidth, ghostZ * tileHeight, tileWidth, tileHeight);
                    }
                });

                minimapCtx.fillStyle = 'blue';
                minimapCtx.fillRect(goal.x / tileSize * tileWidth, goal.z / tileSize * tileHeight, tileWidth, tileHeight);
            } else {
                const minX = Math.max(0, playerTileX - 5);
                const maxX = Math.min(mazeWidth - 1, playerTileX + 4);
                const minZ = Math.max(0, playerTileZ - 5);
                const maxZ = Math.min(mazeHeight - 1, playerTileZ + 4);

                for (let z = minZ; z <= maxZ; z++) {
                    for (let x = minX; x <= maxX; x++) {
                        if (visitedTiles.has(`${x},${z}`)) {
                            if (maze[z][x] === 1) {
                                minimapCtx.fillStyle = 'gray';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 0) {
                                minimapCtx.fillStyle = '#3f2f1f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            } else if (maze[z][x] === 2) {
                                minimapCtx.fillStyle = '#4f4f1f';
                                minimapCtx.fillRect((x - playerTileX + 5) * tileWidth, (z - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                            }
                        }
                    }
                }

                coins.forEach(coin => {
                    const coinX = Math.floor(coin.x / tileSize);
                    const coinZ = Math.floor(coin.z / tileSize);
                    if (!coin.collected && visitedTiles.has(`${coinX},${coinZ}`) && coinX >= minX && coinX <= maxX && coinZ >= minZ && coinZ <= maxZ) {
                        minimapCtx.fillStyle = 'yellow';
                        minimapCtx.fillRect((coinX - playerTileX + 5) * tileWidth, (coinZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                lightSources.forEach(light => {
                    const lightX = Math.floor(light.x / tileSize);
                    const lightZ = Math.floor(light.z / tileSize);
                    if (!light.collected && visitedTiles.has(`${lightX},${lightZ}`) && lightX >= minX && lightX <= maxX && lightZ >= minZ && lightZ <= maxZ) {
                        minimapCtx.fillStyle = 'orange';
                        minimapCtx.fillRect((lightX - playerTileX + 5) * tileWidth, (lightZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                ghosts.forEach(ghost => {
                    const ghostX = Math.floor(ghost.x / tileSize);
                    const ghostZ = Math.floor(ghost.z / tileSize);
                    if (visitedTiles.has(`${ghostX},${ghostZ}`) && ghostX >= minX && ghostX <= maxX && ghostZ >= minZ && ghostZ <= maxZ) {
                        minimapCtx.fillStyle = 'white';
                        minimapCtx.fillRect((ghostX - playerTileX + 5) * tileWidth, (ghostZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                    }
                });

                const goalTileX = Math.floor(goal.x / tileSize);
                const goalTileZ = Math.floor(goal.z / tileSize);
                if (goalTileX >= minX && goalTileX <= maxX && goalTileZ >= minZ && goalTileZ <= maxZ) {
                    minimapCtx.fillStyle = 'blue';
                    minimapCtx.fillRect((goalTileX - playerTileX + 5) * tileWidth, (goalTileZ - playerTileZ + 5) * tileHeight, tileWidth, tileHeight);
                }
            }

            minimapCtx.fillStyle = 'red';
            const playerMapX = isMinimapExpanded ? (playerTileX * tileWidth) : (5 * tileWidth);
            const playerMapZ = isMinimapExpanded ? (playerTileZ * tileHeight) : (5 * tileHeight);
            minimapCtx.fillRect(playerMapX, playerMapZ, tileWidth, tileHeight);

            minimapCtx.restore();
        }

        function resetGame() {
            gameOverOverlay.style.display = 'none';
            score = 0;
            levelsCompleted = 0;
            generateMaze();
            controls.lock();
        }

        function gameLoop() {
            update();
            renderer.render(scene, camera);
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        generateMaze();
        gameLoop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isMinimapExpanded) toggleMinimap();
        });
    </script>
</body>
</html>