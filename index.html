<!DOCTYPE html>
<html>
<head>
    <title>Endless Maze Explorer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            touch-action: none;
        }
        #minimap {
            border: 1px solid black;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        #resultsOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
        }
        #resultsOverlay button {
            padding: 10px 20px;
            font-size: 18px;
            margin-top: 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #resultsOverlay button:hover {
            background-color: #45a049;
        }
        #testMoveButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            background-color: #ff9800;
            color: white;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="320" height="480" tabindex="0"></canvas>
    <canvas id="minimap" width="100" height="200"></canvas>
    <div id="resultsOverlay">
        <h2>Level <span id="levelNumber"></span> Completed!</h2>
        <p>Coins Collected: <span id="coinPoints"></span> points</p>
        <p>Level Bonus: <span id="levelBonus"></span> points</p>
        <p>Total Score: <span id="totalScore"></span></p>
        <button id="nextLevelButton">Next Level</button>
    </div>
    <button id="testMoveButton">Test Move</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const resultsOverlay = document.getElementById('resultsOverlay');
        const levelNumberSpan = document.getElementById('levelNumber');
        const coinPointsSpan = document.getElementById('coinPoints');
        const levelBonusSpan = document.getElementById('levelBonus');
        const totalScoreSpan = document.getElementById('totalScore');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const testMoveButton = document.getElementById('testMoveButton');

        // Game variables
        const tileSize = 40;
        const groundTileSize = tileSize * 4;
        const playerSize = 20;
        const mazeWidth = 50;
        const mazeHeight = 100;
        let player = { x: tileSize, y: tileSize, speed: 5 };
        let goal = { x: 0, y: 0 };
        let maze = [];
        let coins = [];
        let score = 0;
        let levelsCompleted = 0;
        let target = null;
        let path = [];
        let coinsCollectedThisLevel = 0;

        // A* Pathfinding
        function findPath(startX, startY, goalX, goalY) {
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const heuristic = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);
            const start = `${startX},${startY}`;
            const end = `${goalX},${goalY}`;

            gScore.set(start, 0);
            fScore.set(start, heuristic(startX, startY, goalX, goalY));
            openSet.push({ x: startX, y: startY, f: fScore.get(start) });

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                const currentKey = `${current.x},${current.y}`;

                if (currentKey === end) {
                    const path = [];
                    let temp = currentKey;
                    while (cameFrom.has(temp)) {
                        const [x, y] = temp.split(',').map(Number);
                        path.push({ x, y });
                        temp = cameFrom.get(temp);
                    }
                    path.push({ x: startX, y: startY });
                    return path.reverse();
                }

                closedSet.add(currentKey);

                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= mazeWidth || neighbor.y < 0 || neighbor.y >= mazeHeight) continue;
                    if (maze[neighbor.y][neighbor.x] === 1) continue;

                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(neighborKey)) continue;

                    const tentativeG = gScore.get(currentKey) + 1;

                    if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        openSet.push({ x: neighbor.x, y: neighbor.y });
                    } else if (tentativeG >= (gScore.get(neighborKey) || Infinity)) {
                        continue;
                    }

                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeG);
                    fScore.set(neighborKey, tentativeG + heuristic(neighbor.x, neighbor.y, goalX, goalY));
                    openSet.find(n => n.x === neighbor.x && n.y === neighbor.y).f = fScore.get(neighborKey);
                }
            }
            return [];
        }

        // Generate maze with random start and goal
        function generateMaze() {
            maze = [];
            for (let y = 0; y < mazeHeight; y++) {
                let row = [];
                for (let x = 0; x < mazeWidth; x++) {
                    row.push(Math.random() > 0.7 ? 1 : 0);
                }
                maze.push(row);
            }

            let startX, startY, goalX, goalY;
            do {
                startX = Math.floor(Math.random() * mazeWidth);
                startY = Math.floor(Math.random() * mazeHeight);
            } while (maze[startY][startX] === 1);
            maze[startY][startX] = 0;
            player.x = startX * tileSize;
            player.y = startY * tileSize;

            do {
                goalX = Math.floor(Math.random() * mazeWidth);
                goalY = Math.floor(Math.random() * mazeHeight);
            } while (maze[goalY][goalX] === 1 || (goalX === startX && goalY === startY));
            maze[goalY][goalX] = 0;
            goal.x = goalX * tileSize;
            goal.y = goalY * tileSize;

            coins = [];
            for (let i = 0; i < 10; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * mazeWidth);
                    y = Math.floor(Math.random() * mazeHeight);
                } while (maze[y][x] === 1 || (x === startX && y === startY) || (x === goalX && y === goalY));
                coins.push({ x: x * tileSize, y: y * tileSize, collected: false });
            }

            path = findPath(startX, startY, goalX, goalY);
            coinsCollectedThisLevel = 0;
            target = null;
            console.log('Maze generated - player at:', player, 'target:', target);
        }

        // Mouse/Touch controls
        function getCanvasPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const pos = event.touches ? {
                x: event.touches[0].clientX - rect.left,
                y: event.touches[0].clientY - rect.top
            } : {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            console.log('Calculated position:', pos);
            return pos;
        }

        // Bind events with logging
        canvas.addEventListener('mousedown', (e) => {
            if (resultsOverlay.style.display === 'none') {
                target = getCanvasPosition(e);
                console.log('mousedown - target set to:', target);
            } else {
                console.log('mousedown blocked - overlay visible');
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            if (target && resultsOverlay.style.display === 'none') {
                target = getCanvasPosition(e);
                console.log('mousemove - target updated to:', target);
            }
        });
        canvas.addEventListener('mouseup', () => {
            target = null;
            console.log('mouseup - target cleared');
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (resultsOverlay.style.display === 'none') {
                target = getCanvasPosition(e);
                console.log('touchstart - target set to:', target);
            } else {
                console.log('touchstart blocked - overlay visible');
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (target && resultsOverlay.style.display === 'none') {
                target = getCanvasPosition(e);
                console.log('touchmove - target updated to:', target);
            }
        });
        canvas.addEventListener('touchend', () => {
            target = null;
            console.log('touchend - target cleared');
        });

        // Test movement button
        testMoveButton.addEventListener('click', () => {
            target = { x: player.x + 100, y: player.y + 100 };
            console.log('Test Move clicked - target set to:', target);
        });

        // Collision check function
        function canMoveTo(newX, newY) {
            let playerTileX = Math.floor(newX / tileSize);
            let playerTileY = Math.floor(newY / tileSize);
            let playerRight = Math.floor((newX + playerSize - 1) / tileSize);
            let playerBottom = Math.floor((newY + playerSize - 1) / tileSize);

            if (newX < 0 || newX > mazeWidth * tileSize - playerSize || 
                newY < 0 || newY > mazeHeight * tileSize - playerSize) {
                return false;
            }

            const canMove = maze[playerTileY][playerTileX] === 0 && 
                            maze[playerTileY][playerRight] === 0 &&
                            maze[playerBottom][playerTileX] === 0 &&
                            maze[playerBottom][playerRight] === 0;
            console.log('canMoveTo:', newX, newY, 'result:', canMove);
            return canMove;
        }

        // Show results overlay
        function showResults() {
            const coinPoints = coinsCollectedThisLevel * 10 * (levelsCompleted);
            const levelBonus = 50 * levelsCompleted;
            levelNumberSpan.textContent = levelsCompleted;
            coinPointsSpan.textContent = coinPoints;
            levelBonusSpan.textContent = levelBonus;
            totalScoreSpan.textContent = score;
            resultsOverlay.style.display = 'block';
            target = null;
            console.log('Results shown - target cleared');
        }

        // Update game state
        function update() {
            if (resultsOverlay.style.display === 'block') {
                console.log('Update paused - overlay visible');
                return;
            }

            if (target) {
                console.log('Updating with target:', target, 'player at:', player.x, player.y);
                let cameraX = player.x - canvas.width / 2;
                let cameraY = player.y - canvas.height / 2;
                if (cameraX < 0) cameraX = 0;
                if (cameraY < 0) cameraY = 0;
                if (cameraX > mazeWidth * tileSize - canvas.width) cameraX = mazeWidth * tileSize - canvas.width;
                if (cameraY > mazeHeight * tileSize - canvas.height) cameraY = mazeHeight * tileSize - canvas.height;

                const targetWorldX = target.x + cameraX;
                const targetWorldY = target.y + cameraY;

                const dx = targetWorldX - (player.x + playerSize / 2);
                const dy = targetWorldY - (player.y + playerSize / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                console.log('Distance to target:', distance);

                if (distance > 10) {
                    const angle = Math.atan2(dy, dx);
                    const moveX = Math.cos(angle) * player.speed;
                    const moveY = Math.sin(angle) * player.speed;

                    let newX = player.x + moveX;
                    let newY = player.y;
                    if (canMoveTo(newX, newY)) {
                        player.x = newX;
                        console.log('Moved X to:', player.x);
                    } else {
                        console.log('X movement blocked at:', newX, newY);
                    }

                    newX = player.x;
                    newY = player.y + moveY;
                    if (canMoveTo(newX, newY)) {
                        player.y = newY;
                        console.log('Moved Y to:', player.y);
                    } else {
                        console.log('Y movement blocked at:', newX, newY);
                    }
                } else {
                    console.log('Distance too small:', distance);
                }
            } else {
                console.log('No target set');
            }

            coins.forEach((coin, index) => {
                if (!coin.collected &&
                    player.x < coin.x + tileSize &&
                    player.x + playerSize > coin.x &&
                    player.y < coin.y + tileSize &&
                    player.y + playerSize > coin.y) {
                    coin.collected = true;
                    coinsCollectedThisLevel++;
                    score += 10 * (levelsCompleted + 1);
                    console.log('Coin collected - score:', score);
                }
            });
            coins = coins.filter(coin => !coin.collected);

            let playerTileX = Math.floor(player.x / tileSize);
            let playerTileY = Math.floor(player.y / tileSize);
            let goalTileX = Math.floor(goal.x / tileSize);
            let goalTileY = Math.floor(goal.y / tileSize);
            if (playerTileX === goalTileX && playerTileY === goalTileY) {
                levelsCompleted++;
                const levelBonus = 50 * levelsCompleted;
                score += levelBonus;
                showResults();
            }
        }

        // Reset game
        function resetGame() {
            player.x = tileSize;
            player.y = tileSize;
            maze = [];
            coins = [];
            score = 0;
            levelsCompleted = 0;
            target = null;
            coinsCollectedThisLevel = 0;
            generateMaze();
        }

        // Draw main game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let cameraX = player.x - canvas.width / 2;
            let cameraY = player.y - canvas.height / 2;
            if (cameraX < 0) cameraX = 0;
            if (cameraY < 0) cameraY = 0;
            if (cameraX > mazeWidth * tileSize - canvas.width) cameraX = mazeWidth * tileSize - canvas.width;
            if (cameraY > mazeHeight * tileSize - canvas.height) cameraY = mazeHeight * tileSize - canvas.height;

            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            ctx.fillStyle = '#d3d3d3';
            for (let y = 0; y < mazeHeight; y += 4) {
                for (let x = 0; x < mazeWidth; x += 4) {
                    if (maze[y][x] === 0) {
                        ctx.fillRect(x * tileSize, y * tileSize, groundTileSize, groundTileSize);
                    }
                }
            }

            ctx.fillStyle = 'green';
            path.forEach(p => {
                ctx.fillRect(p.x * tileSize, p.y * tileSize, tileSize, tileSize);
            });

            ctx.fillStyle = 'gray';
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            ctx.fillStyle = 'yellow';
            coins.forEach(coin => {
                if (!coin.collected) {
                    ctx.beginPath();
                    ctx.arc(coin.x + tileSize / 2, coin.y + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.fillStyle = 'blue';
            ctx.fillRect(goal.x, goal.y, tileSize, tileSize);

            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, playerSize, playerSize);

            ctx.restore();

            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score} | Level: ${levelsCompleted + 1} | Coins: ${coins.length}`, 10, 30);
        }

        // Draw minimap
        function drawMinimap() {
            const miniTileWidth = minimapCanvas.width / mazeWidth;
            const miniTileHeight = minimapCanvas.height / mazeHeight;

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            minimapCtx.fillStyle = 'green';
            path.forEach(p => {
                minimapCtx.fillRect(p.x * miniTileWidth, p.y * miniTileHeight, miniTileWidth, miniTileHeight);
            });

            minimapCtx.fillStyle = 'gray';
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        minimapCtx.fillRect(x * miniTileWidth, y * miniTileHeight, miniTileWidth, miniTileHeight);
                    }
                }
            }

            minimapCtx.fillStyle = 'yellow';
            coins.forEach(coin => {
                if (!coin.collected) {
                    minimapCtx.fillRect(
                        (coin.x / tileSize) * miniTileWidth,
                        (coin.y / tileSize) * miniTileHeight,
                        miniTileWidth,
                        miniTileHeight
                    );
                }
            });

            minimapCtx.fillStyle = 'blue';
            minimapCtx.fillRect(
                (goal.x / tileSize) * miniTileWidth,
                (goal.y / tileSize) * miniTileHeight,
                miniTileWidth,
                miniTileHeight
            );

            minimapCtx.fillStyle = 'red';
            minimapCtx.fillRect(
                (player.x / tileSize) * miniTileWidth,
                (player.y / tileSize) * miniTileHeight,
                miniTileWidth,
                miniTileHeight
            );
        }

        // Next level button handler
        nextLevelButton.addEventListener('click', () => {
            resultsOverlay.style.display = 'none';
            generateMaze();
            console.log('Next level clicked - overlay hidden');
        });

        // Game loop
        function gameLoop() {
            update();
            draw();
            drawMinimap();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        console.log('Game starting - overlay display:', resultsOverlay.style.display);
        canvas.focus(); // Ensure canvas has focus for events
        generateMaze();
        gameLoop();
    </script>
</body>
</html>